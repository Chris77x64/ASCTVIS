(self.webpackChunkasct=self.webpackChunkasct||[]).push([[365],{473:function(Z,j){var Y;void 0!==(Y=function(){"use strict";function u(d,v,I){var w=new XMLHttpRequest;w.open("GET",d),w.responseType="blob",w.onload=function(){f(w.response,v,I)},w.onerror=function(){console.error("could not download file")},w.send()}function J(d){var v=new XMLHttpRequest;v.open("HEAD",d,!1);try{v.send()}catch(I){}return 200<=v.status&&299>=v.status}function N(d){try{d.dispatchEvent(new MouseEvent("click"))}catch(I){var v=document.createEvent("MouseEvents");v.initMouseEvent("click",!0,!0,window,0,0,0,80,20,!1,!1,!1,!1,0,null),d.dispatchEvent(v)}}var C="object"==typeof window&&window.window===window?window:"object"==typeof self&&self.self===self?self:"object"==typeof global&&global.global===global?global:void 0,R=C.navigator&&/Macintosh/.test(navigator.userAgent)&&/AppleWebKit/.test(navigator.userAgent)&&!/Safari/.test(navigator.userAgent),f=C.saveAs||("object"!=typeof window||window!==C?function(){}:"download"in HTMLAnchorElement.prototype&&!R?function(d,v,I){var w=C.URL||C.webkitURL,D=document.createElement("a");D.download=v=v||d.name||"download",D.rel="noopener","string"==typeof d?(D.href=d,D.origin===location.origin?N(D):J(D.href)?u(d,v,I):N(D,D.target="_blank")):(D.href=w.createObjectURL(d),setTimeout(function(){w.revokeObjectURL(D.href)},4e4),setTimeout(function(){N(D)},0))}:"msSaveOrOpenBlob"in navigator?function(d,v,I){if(v=v||d.name||"download","string"!=typeof d)navigator.msSaveOrOpenBlob(function(d,v){return void 0===v?v={autoBom:!1}:"object"!=typeof v&&(console.warn("Deprecated: Expected third argument to be a object"),v={autoBom:!v}),v.autoBom&&/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(d.type)?new Blob(["\ufeff",d],{type:d.type}):d}(d,I),v);else if(J(d))u(d,v,I);else{var w=document.createElement("a");w.href=d,w.target="_blank",setTimeout(function(){N(w)})}}:function(d,v,I,w){if((w=w||open("","_blank"))&&(w.document.title=w.document.body.innerText="downloading..."),"string"==typeof d)return u(d,v,I);var D="application/octet-stream"===d.type,ee=/constructor/i.test(C.HTMLElement)||C.safari,T=/CriOS\/[\d]+/.test(navigator.userAgent);if((T||D&&ee||R)&&"undefined"!=typeof FileReader){var B=new FileReader;B.onloadend=function(){var A=B.result;A=T?A:A.replace(/^data:[^;]*;/,"data:attachment/file;"),w?w.location.href=A:location=A,w=null},B.readAsDataURL(d)}else{var U=C.URL||C.webkitURL,G=U.createObjectURL(d);w?w.location=G:location.href=G,w=null,setTimeout(function(){U.revokeObjectURL(G)},4e4)}});C.saveAs=f.saveAs=f,Z.exports=f}.apply(j,[]))&&(Z.exports=Y)},365:(Z,j,S)=>{"use strict";S.r(j),S.d(j,{GraphController:()=>gt});var P=S(239);class Y{constructor(){this.initialize()}initialize(){this.withDrawingDIV=document.getElementById("drawing").offsetWidth,this.heightDrawingDIV=document.getElementById("drawing").offsetHeight,this.totalWidth=this.withDrawingDIV-.05*this.withDrawingDIV,this.vertexSize=Math.sqrt(window.screen.height*window.screen.height+window.screen.width*window.screen.width)/2,this.rootExplorationVertexSize=1.5*this.vertexSize,this.maxContainmentCollapsedVertexSize=2*this.vertexSize,this.vertexLabelSize=14,this.offsetIncrementTwoLines=2*Math.sqrt(this.vertexSize),this.offsetIncrementOneLine=2*Math.sqrt(this.vertexSize),this.oneLineLabelOffset=-Math.sqrt(this.vertexSize),this.twoLineLabelOffset=-Math.sqrt(this.vertexSize)-this.vertexLabelSize,this.collapsedCTLabelOffset=-this.vertexLabelSize/2,this.rootExplorationTwoLineLabelOffset=-Math.sqrt(this.rootExplorationVertexSize)-this.vertexLabelSize,this.rootExplorationOneLineLabelOffset=-Math.sqrt(this.rootExplorationVertexSize),this.heightTopPadding=this.offsetIncrementTwoLines,this.widthRightPadding=.05*this.withDrawingDIV}}var u=(()=>{return(l=u||(u={}))[l.BoneMarrow=0]="BoneMarrow",l[l.Brain=1]="Brain",l[l.Heart=2]="Heart",l[l.Kidney=3]="Kidney",l[l.LargeIntestine=4]="LargeIntestine",l[l.Lung=5]="Lung",l[l.LymphNodes=6]="LymphNodes",l[l.Skin=7]="Skin",l[l.Spleen=8]="Spleen",l[l.Thymus=9]="Thymus",l[l.Vasculature=10]="Vasculature",l[l.All=11]="All",l[l.HeartWithCTTypology=12]="HeartWithCTTypology",u;var l})();function R(){return(R=(0,P.Z)(function*(l,e){if(l in e.IDtoOntologyID){let t="https://asctb-api.herokuapp.com/lookup/";switch(e.IDtoOntologyType[l]){case d.UBERON:t+="UBERON/"+e.IDtoOntologyID[l];break;case d.FMAID:t+="FMA/"+e.IDtoOntologyID[l];break;case d.HGNC:t+="HGNC/"+e.IDtoOntologyID[l];break;case d.CL:t+="CL/"+e.IDtoOntologyID[l]}return yield(yield fetch(t)).json()}return Promise.reject()})).apply(this,arguments)}var f=(()=>{return(l=f||(f={}))[l.AS=0]="AS",l[l.CT=1]="CT",l[l.BM=2]="BM",f;var l})(),d=(()=>{return(l=d||(d={}))[l.UBERON=0]="UBERON",l[l.FMAID=1]="FMAID",l[l.HGNC=2]="HGNC",l[l.CL=3]="CL",d;var l})();class ee extends class{constructor(e){this.verticesCT=e,this.outDegree=new Map,this.containerState=new Map,this.containmentLeaves=new Map,this.artificialID=-8e5,this.artificialIDToInnerVertex=new Map,this.initializeContainment(),this.parseInitialContainment(),this.parseAbstractRectangles()}parseContainment(){this.containmentLeaves=new Map,this.artificialIDToInnerVertex=new Map,this.artificialID=-8e5,this.containment=this.worker(this.root)}reset(){this.containmentLeaves=new Map,this.artificialID=-8e5,this.parseInitialContainment()}expand(e){e in this.artificialIDToInnerVertex?(this.containerState[this.artificialIDToInnerVertex[e]]=!0,this.expandWorker(this.artificialIDToInnerVertex[e])):(this.containerState[e]=!0,this.expandWorker(e))}expandWorker(e){this.containerState[e]=!0,e in this.outDegree&&this.outDegree[e].forEach(t=>{this.containerState[t]=!0,this.expandWorker(t)})}collapse(e){this.containerState[e]=!1}worker(e){if(e in this.outDegree){if(1==this.containerState[e]){let t=[];return this.outDegree[e].forEach(i=>{t=t.concat(this.worker(i))}),this.containmentLeaves[e]=t,t}return this.artificialID=this.artificialID-1,this.containmentLeaves[e]=this.artificialID,this.artificialIDToInnerVertex[this.artificialID]=[e],[this.artificialID]}return this.containmentLeaves[e]=[e],[e]}parseInitialContainment(){this.containment=this.workerInitial(this.root)}workerInitial(e){if(this.containerState[e]=!0,e in this.outDegree){let t=[];return this.outDegree[e].forEach(i=>{t=t.concat(this.workerInitial(i))}),this.containmentLeaves[e]=t,t}return this.containmentLeaves[e]=[e],[e]}calculateFakeOutDeg(){this.aid=-8e5;let e=new Map;return this.worker2(this.root,e),e[this.root]=this.outDegree[this.root],e}worker2(e,t){e in this.outDegree&&(1==this.containerState[e]?(this.outDegree[e].forEach(i=>{this.worker2(i,t)}),t[e]=this.outDegree[e]):(this.aid=this.aid-1,t[e]=[this.aid]))}parseAbstractRectangles(){let e=this.root;this.numRectangles=0,this.rectangleMap=new Map,this.rectIDArtificialIDMap=new Map,this.artificialIdRectIDMap=new Map,e in this.outDegree&&this.outDegree[e].forEach(t=>{this.abstractRectangleWorker(t)})}abstractRectangleWorker(e){e in this.outDegree&&(1==this.containerState[e]?(this.rectangleMap[this.numRectangles]=this.containmentLeaves[e],this.rectIDArtificialIDMap[this.numRectangles]=e,this.artificialIdRectIDMap[e]=this.numRectangles,this.numRectangles+=1,this.outDegree[e].forEach(t=>{this.abstractRectangleWorker(t)})):(this.rectangleMap[this.numRectangles]=this.containmentLeaves[e],this.rectIDArtificialIDMap[this.numRectangles]=e,this.artificialIdRectIDMap[e]=this.numRectangles,this.numRectangles+=1))}update(){this.parseContainment(),this.parseAbstractRectangles()}}{constructor(e){super(e)}initializeContainment(){let e=this.verticesCT.map(i=>({value:i,sort:Math.random()})).sort((i,s)=>i.sort-s.sort).map(({value:i})=>i),t=-4e5;if(2==this.verticesCT.length)this.outDegree=new Map,this.outDegree[t]=[t+1,t+2],this.outDegree[t+1]=[e[0]],this.outDegree[t+2]=[e[1]],this.root=t,this.initialRoot=this.root;else{let i=e.splice(0);for(;i.length>1;){let s=[];for(let r=1;r<i.length;r+=2)s.push(t),this.outDegree[t]=i.length%2==1&&r+1==i.length-1?[i[r-1],i[r],i[r+1]]:[i[r-1],i[r]],t-=1;i=s}this.root=i[0],this.initialRoot=this.root}}}class T{constructor(e){if(this.vertexSize=new Map,1==e.length){this.organ=e[0],this.vertices=[],this.inDegree=new Map,this.outDegree=new Map,this.vertexType=new Map,this.vertexLabel=new Map,this.vertexVisible=new Map,this.vertexColor=new Map,this.IDtoOntologyType=new Map,this.IDtoOntologyID=new Map,this.ready=!1;const t=function(l){const s="https://asctb-api.herokuapp.com/v2/1tK916JyG5ZSXW_cXfsyZnzXfjyoN-8B2GXLbYD6_vF0/";switch(l){case u.BoneMarrow:return s+"1845311048/graph";case u.Brain:return s+"1379088218/graph";case u.Heart:return"https://asctb-api.herokuapp.com/v2/csv?output=graph&csvUrl=https://hubmapconsortium.github.io/ccf-releases/v1.0/asct-b/ASCT-B_VH_Heart.csv";case u.HeartWithCTTypology:return"https://asctb-api.herokuapp.com/v2/csv?output=graph&csvUrl=https://hubmap-link-api.herokuapp.com/asctb/UBERON:0000948";case u.Kidney:return s+"2137043090/graph";case u.LargeIntestine:return s+"512613979/graph";case u.Lung:return s+"1824552484/graph";case u.LymphNodes:return s+"1440276882/graph";case u.Skin:return s+"1158675184/graph";case u.Spleen:return s+"984946629/graph";case u.Thymus:return s+"1823527529/graph";case u.Vasculature:return s+"361657182/graph";default:return}}(this.organ);this.readyPromise=this.initializeGraph(t).then(i=>{let s=Math.sqrt(window.screen.height*window.screen.height+window.screen.width*window.screen.width)/2;this.vertices.forEach(r=>this.vertexSize[r]=s),this.ready=!0,this.containment=new ee(this.verticesCT)})}else this.organ=e[0],this.vertices=e[1],this.inDegree=e[2],this.outDegree=e[3],this.vertexType=e[4],this.vertexLabel=e[5],this.vertexVisible=e[6],this.vertexColor=e[7],this.IDtoOntologyType=e[8],this.IDtoOntologyID=e[9],this.verticesAS=[],this.verticesCT=[],this.verticesBM=[],this.numVertices=this.vertices.length,this.numVerticesAS=0,this.numVerticesCT=0,this.numVerticesBM=0,this.vertices.forEach(t=>{switch(this.vertexType[t]){case f.AS:this.verticesAS.push(t),this.numVerticesAS+=1;break;case f.CT:this.verticesCT.push(t),this.numVerticesCT+=1;break;case f.BM:this.verticesBM.push(t),this.numVerticesBM+=1}this.vertexSize[t]=300}),this.ready=!0}processOntologyID(e,t){if(""!=e.ontologyId){let i=e.ontologyId;if(-1!=i.indexOf(":")){i=i.split(" ")[0];const[r,n]=i.split(":");switch(r){case"HGNC":this.IDtoOntologyType[t]=d.HGNC;break;case"UBERON":this.IDtoOntologyType[t]=d.UBERON;break;case"FMAID":this.IDtoOntologyType[t]=d.FMAID;break;case"CL":this.IDtoOntologyType[t]=d.CL}this.IDtoOntologyID[t]=n}}}initializeGraph(e){var t=this;return(0,P.Z)(function*(){let i;i=yield fetch(function(l){switch(l){case u.BoneMarrow:return"assets/csv/graphBoneMarrow.json";case u.Brain:return"assets/csv/graphBrain.json";case u.Heart:return"assets/csv/graphHeart.json";case u.HeartWithCTTypology:return"assets/csv/graphHeartjson";case u.Kidney:return"assets/csv/graphKidney.json";case u.LargeIntestine:return"assets/csv/graphLargeIntestine.json";case u.Lung:return"assets/csv/graphLung.json";case u.LymphNodes:return"assets/csv/graphLymphNodes.json";case u.Skin:return"assets/csv/graphSkin.json";case u.Spleen:return"assets/csv/graphSpleen.json";case u.Thymus:return"assets/csv/graphThymus.json";case u.Vasculature:return"assets/csv/graphVasculature.json";default:return}}(t.organ)).then(s=>s.json()).then(s=>s.data),t.verticesAS=[],t.verticesCT=[],t.verticesBM=[];for(const s of i.nodes){const{id:r,type:n,name:a,metadata:o}=s;switch(t.processOntologyID(o,r),n){case"AS":t.vertexType[r]=f.AS,t.vertexColor[r]="red",t.verticesAS.push(r);break;case"CT":t.vertexType[r]=f.CT,t.vertexColor[r]="blue",t.verticesCT.push(r);break;case"BM":t.vertexType[r]=f.BM,t.verticesBM.push(r),t.vertexColor[r]="gene"==o.bmType?"green":"Chartreuse"}t.vertexVisible[r]=1,t.vertices.push(r),t.vertexLabel[r]=a}for(const s of i.edges){const{source:r,target:n}=s;t.vertexType[r]==f.CT&&t.vertexType[n]==f.CT&&t.organ==u.Heart&&console.log("SOURCE: ",r,"TARGET",n,t.organ),(t.vertexType[r]!=f.CT||t.vertexType[n]!=f.CT)&&(t.vertexType[r]!=f.AS||t.vertexType[n]!=f.BM)&&(n in t.inDegree?t.inDegree[n].includes(r)||t.inDegree[n].push(r):t.inDegree[n]=[r],r in t.outDegree?t.outDegree[r].includes(n)||t.outDegree[r].push(n):t.outDegree[r]=[n])}t.numVerticesAS=t.verticesAS.length,t.numVerticesCT=t.verticesCT.length,t.numVerticesBM=t.verticesBM.length,t.numVertices=t.numVerticesAS+t.numVerticesCT+t.numVerticesBM})()}}var B=S(732);function ne(l,e,t){if((0,B.kJ)(l))return`[${l.map(i=>e((0,B.HD)(i)?i:ae(i,t))).join(", ")}]`;if((0,B.Kn)(l)){let i="";const s=l,{title:r,image:n}=s,a=function(l,e){var t={};for(var i in l)Object.prototype.hasOwnProperty.call(l,i)&&e.indexOf(i)<0&&(t[i]=l[i]);if(null!=l&&"function"==typeof Object.getOwnPropertySymbols){var s=0;for(i=Object.getOwnPropertySymbols(l);s<i.length;s++)e.indexOf(i[s])<0&&Object.prototype.propertyIsEnumerable.call(l,i[s])&&(t[i[s]]=l[i[s]])}return t}(s,["title","image"]);r&&(i+=`<h2>${e(r)}</h2>`),n&&(i+=`<img src="${e(n)}">`);const o=Object.keys(a);if(o.length>0){i+="<table>";for(const h of o){let c=a[h];void 0!==c&&((0,B.Kn)(c)&&(c=ae(c,t)),i+=`<tr><td class="key">${e(h)}:</td><td class="value">${e(c)}</td></tr>`)}i+="</table>"}return i||"{}"}return e(l)}function ae(l,e){return JSON.stringify(l,function(l){const e=[];return function(t,i){if("object"!=typeof i||null===i)return i;const s=e.indexOf(this)+1;return e.length=s,e.length>l?"[Object]":e.indexOf(i)>=0?"[Circular]":(e.push(i),i)}}(e))}const oe="vg-tooltip-element",Ge={offsetX:10,offsetY:10,id:oe,styleId:"vega-tooltip-style",theme:"light",disableDefaultStyle:!1,sanitize:function(l){return String(l).replace(/&/g,"&amp;").replace(/</g,"&lt;")},maxDepth:2,formatTooltip:ne};class le{constructor(e){this.options=Object.assign(Object.assign({},Ge),e);const t=this.options.id;if(this.el=null,this.call=this.tooltipHandler.bind(this),!this.options.disableDefaultStyle&&!document.getElementById(this.options.styleId)){const i=document.createElement("style");i.setAttribute("id",this.options.styleId),i.innerHTML=function(l){if(!/^[A-Za-z]+[-:.\w]*$/.test(l))throw new Error("Invalid HTML ID");return"#vg-tooltip-element {\n  visibility: hidden;\n  padding: 8px;\n  position: fixed;\n  z-index: 1000;\n  font-family: sans-serif;\n  font-size: 11px;\n  border-radius: 3px;\n  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);\n  /* The default theme is the light theme. */\n  background-color: rgba(255, 255, 255, 0.95);\n  border: 1px solid #d9d9d9;\n  color: black; }\n  #vg-tooltip-element.visible {\n    visibility: visible; }\n  #vg-tooltip-element h2 {\n    margin-top: 0;\n    margin-bottom: 10px;\n    font-size: 13px; }\n  #vg-tooltip-element img {\n    max-width: 200px;\n    max-height: 200px; }\n  #vg-tooltip-element table {\n    border-spacing: 0; }\n    #vg-tooltip-element table tr {\n      border: none; }\n      #vg-tooltip-element table tr td {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        padding-top: 2px;\n        padding-bottom: 2px; }\n        #vg-tooltip-element table tr td.key {\n          color: #808080;\n          max-width: 150px;\n          text-align: right;\n          padding-right: 4px; }\n        #vg-tooltip-element table tr td.value {\n          display: block;\n          max-width: 300px;\n          max-height: 7em;\n          text-align: left; }\n  #vg-tooltip-element.dark-theme {\n    background-color: rgba(32, 32, 32, 0.9);\n    border: 1px solid #f5f5f5;\n    color: white; }\n    #vg-tooltip-element.dark-theme td.key {\n      color: #bfbfbf; }\n".toString().replace(oe,l)}(t);const s=document.head;s.childNodes.length>0?s.insertBefore(i,s.childNodes[0]):s.appendChild(i)}}tooltipHandler(e,t,i,s){var r;if(this.el=document.getElementById(this.options.id),this.el||(this.el=document.createElement("div"),this.el.setAttribute("id",this.options.id),this.el.classList.add("vg-tooltip"),document.body.appendChild(this.el)),(null!==(r=document.fullscreenElement)&&void 0!==r?r:document.body).appendChild(this.el),null==s||""===s)return void this.el.classList.remove("visible",`${this.options.theme}-theme`);this.el.innerHTML=this.options.formatTooltip(s,this.options.sanitize,this.options.maxDepth),this.el.classList.add("visible",`${this.options.theme}-theme`);const{x:a,y:o}=function(l,e,t,i){let s=l.clientX+t;s+e.width>window.innerWidth&&(s=+l.clientX-t-e.width);let r=l.clientY+i;return r+e.height>window.innerHeight&&(r=+l.clientY-i-e.height),{x:s,y:r}}(t,this.el.getBoundingClientRect(),this.options.offsetX,this.options.offsetY);this.el.setAttribute("style",`top: ${o}px; left: ${a}px`)}}class je{constructor(e){this.currentString="",this.lastID=null,this.controller=e}compute(e,t,i){if(this.controller.gui.appearance[1].sel){let r=this.createTooltip();this.processEvent(e,t,r,i)}else this.removeCurrentTooltip()}processOntologyStrings(e,t){let i="Not Available ",s="Not Available";if(e in t.IDtoOntologyID)switch(i=t.IDtoOntologyID[e],t.IDtoOntologyType[e]){case d.UBERON:s="UBERON";break;case d.CL:s="CL";break;case d.HGNC:s="HGNC";break;case d.FMAID:s="FMAID"}return[s,i]}processDescription(e){let t=e.description,i=" ",s=t.split(" "),r=0,n=e.link.length-4;return s.forEach(a=>{r>n&&(i+="<br>",r=0),i+=a+" ",r+=a.length}),0!=t.length?i:"Not Available "}processColor(e,t){let i="";switch(e.vertexType[t]){case f.AS:i="red";break;case f.CT:i="deepskyblue";break;case f.BM:i="greenyellow"}return"color:"+i}processEvent(e,t,i,s){if(null!=t){let r=t.datum.id;r!=this.lastID&&function(l,e){return R.apply(this,arguments)}(r,s).then(n=>{if(null!=n){let[a,o]=this.processOntologyStrings(r,s),h=this.processDescription(n),c=this.processColor(s,r);this.currentString="<div style='font-size: 2vh'> <u>Name:</u>  "+s.vertexLabel[r]+"<br>Database:  "+a+"<br>Ontology ID:  "+o+"<br><div style="+c+">"+n.link+"</div><u>  Description: </u> <br>"+h+"</div>",i.call(i,e,{},"foo")}}).catch(n=>{this.removeCurrentTooltip()}),this.lastID=r}else this.removeCurrentTooltip()}removeCurrentTooltip(){let e=document.getElementById("vg-tooltip-element");null!=e&&e.remove()}createTooltip(){return new le({offsetX:30,offsetY:10,id:"vg-tooltip-element",styleId:"vega-tooltip-style",theme:"dark",disableDefaultStyle:!1,sanitize:t=>this.currentString,formatTooltip:ne})}}var Xe=S(473);class V{constructor(e){this.rotateAngle=this.rotateStringToNumber(e),this.rotate=0!=this.rotateAngle}rotateStringToNumber(e){switch(e){case"90 Degree":return 180;case"180 Degree":return 90;case"270 Degree":return 270;default:return 0}}}class F{constructor(e,t){this.type=t,this.controller=e,this.toolTip=new je(e),this.firstTime=!0}exportImage(){var e=this;return(0,P.Z)(function*(){let t=yield e.currentView.toSVG(),i=new Blob([t],{type:"image/svg+xml"});Xe(i,"graph.jpg")})()}contentRectInDrawingArea(){let e=!1,t=document.querySelectorAll(".mark-symbol.role-mark");if(t.length>0){let i=t[0].getBoundingClientRect();i.height<this.controller.properties.heightDrawingDIV&&i.width<this.controller.properties.withDrawingDIV&&(e=!0)}return e}fitContent(e){let t=document.querySelectorAll(".mark-symbol.role-mark");if(t.length>0){"Explore"!=this.type&&this.controller.currentMode.reset();let i=t[0].getBoundingClientRect(),s=new V(this.controller.gui.selectedRotation);e.signal("xdom",[0,e.signal("width")]),e.signal("ydom",[0,e.signal("height")]),e.signal("sizeVertexDom",[50,300]),e.signal("xdomContainment",[0,e.signal("width")]),e.signal("ydomContainment",[0,e.signal("height")]),e.signal("sizeLabelDom",[6,8]),e.signal("anchor","Explore"==this.type||180==s.rotateAngle||270==s.rotateAngle?[0,0]:[this.controller.properties.totalWidth/2,0]),e.signal("zoom",i.width>i.height?i.width/(.98*this.controller.properties.totalWidth):i.height/(.9*this.controller.properties.heightDrawingDIV)),e.runAsync().then(()=>{this.currentView=e})}}setBackground(e){e.signal("background",this.darkMode?"black":"white")}setGraph2DParameter(e){let t=this.controller.gui.appearance[2].sel,i=this.controller.gui.appearance[0].sel;this.darkMode=t,e.graphStyle.labelEnabled=i,t?(e.graphStyle.darkMode=!0,e.graphStyle.labelFill="#fff"):(e.graphStyle.darkMode=!1,e.graphStyle.labelFill="#000")}updateView(e,t){let i=t.getState();i.data=e.getState().data,i.signals.width=e.getState().signals.width,i.signals.height=e.getState().signals.height,e.setState(i),t.finalize()}calculateContainerStrings(){let e=this.controller.graphs[this.controller.currentOrgan].containment,t=[],i=1;return e.outDegree[e.initialRoot].forEach(s=>{t.push("Container "+i),i+=1}),t}}const Ue={$schema:"https://vega.github.io/schema/vega/v5.json",description:"Graph Drawing",padding:{top:25,left:0,right:0,bottom:0},autosize:"none",signals:[{name:"shape",value:"line"},{name:"xrange",update:"[0, width]"},{name:"yrange",update:"[ 0,height]"},{name:"down",value:null,on:[{events:"touchend",update:"null"},{events:"mousedown, touchstart",update:"xy()"}]},{name:"hover",on:[{events:"*:mouseover",encode:"hover"},{events:"*:mouseout",encode:"leave"},{events:"*:mousedown",encode:"select"},{events:"*:mouseup",encode:"release"}]},{name:"xoffset",update:"-(width + padding.bottom)"},{name:"yoffset",update:"-(height + padding.left)"},{name:"xcur",value:null,on:[{events:"mousedown, touchstart, touchend",update:"slice(xdom)"}]},{name:"ycur",value:null,on:[{events:"mousedown, touchstart, touchend",update:"slice(ydom)"}]},{name:"delta",value:[0,0],on:[{events:[{source:"window",type:"mousemove",consume:!0,between:[{type:"mousedown"},{source:"window",type:"mouseup"}]},{type:"touchmove",consume:!0,filter:"event.touches.length === 1"}],update:"down ? [down[0]-x(), y()-down[1]] : [0,0]"}]},{name:"anchor",value:[0,0],on:[{events:"wheel",update:"[ invert('xscale', x()), invert('yscale', y())]"}]},{name:"zoom",value:1,on:[{events:"wheel!",force:!0,update:"pow(1.001, event.deltaY)"}]},{name:"dist1",value:0,on:[{events:{type:"touchstart",filter:"event.touches.length===2"},update:"pinchDistance(event)"},{events:{signal:"dist2"},update:"dist2"}]},{name:"dist2",value:0,on:[{events:{type:"touchmove",consume:!0,filter:"event.touches.length===2"},update:"pinchDistance(event)"}]},{name:"sizeLabelRange",update:"[8,14]"},{name:"sizeLabelDom",update:"[8,14]",on:[{events:{signal:"zoom"},update:"[ sizeLabelDom[0] * zoom, sizeLabelDom[1] * zoom]"}]},{name:"sizeVertexRange",update:"[50,300]"},{name:"sizeVertexDom",update:"[50,300]",on:[{events:{signal:"zoom"},update:"[ sizeVertexDom[0] * zoom, sizeVertexDom[1] * zoom]"}]},{name:"ydomLabelOffset",update:"[0,height]",on:[{events:{signal:"zoom"},update:"[ydomLabelOffset[0], ydomLabelOffset[1]]"}]},{name:"xdomContainment",update:"[0,width]",on:[{events:{signal:"zoom"},update:"[ xdomContainment[0] * zoom, xdomContainment[1] * zoom]"}]},{name:"ydomContainment",update:"[0,height]",on:[{events:{signal:"zoom"},update:"[ydomContainment[0]* zoom, ydomContainment[1] * zoom]"}]},{name:"xdom",update:"[0,width]",on:[{events:{signal:"delta"},update:"[xcur[0] + span(xcur) * delta[0] / width, xcur[1] + span(xcur) * delta[0] / width]"},{events:{signal:"zoom"},update:"[anchor[0] + (xdom[0] - anchor[0]) * zoom, anchor[0] + (xdom[1] - anchor[0]) * zoom]"}]},{name:"ydom",update:"[0,height]",on:[{events:{signal:"delta"},update:"[ycur[0] - span(ycur) * delta[1] / height, ycur[1] - span(ycur) * delta[1] / height]"},{events:{signal:"zoom"},update:"[anchor[1] + (ydom[0] - anchor[1]) * zoom, anchor[1] + (ydom[1] - anchor[1]) * zoom]"}]},{name:"xdomC2",update:"[0,width]",on:[{events:{signal:"zoom"},update:"[anchor[0] + (xdom[0] - anchor[0]) * zoom, anchor[0] + (xdom[1] - anchor[0]) * zoom]"}]},{name:"ydomC2",update:"[0,height]",on:[{events:{signal:"zoom"},update:"[anchor[1] + (ydom[0] - anchor[1]) * zoom, anchor[1] + (ydom[1] - anchor[1]) * zoom]"}]}],data:[{name:"vertices",values:[]},{name:"edges",values:[],transform:[{type:"lookup",from:"vertices",key:"id",fields:["source","target"],as:["source","target"]},{type:"linkpath",shape:"diagonal",orient:"horizontal",sourceX:{field:"source.x",scale:"xscale"},sourceY:{field:"source.y",scale:"yscale"},targetX:{field:"target.x",scale:"xscale"},targetY:{field:"target.y",scale:"yscale"},as:"lp"}]},{name:"rects",values:[]},{name:"edges2",values:[],transform:[{type:"lookup",from:"vertices",key:"id",fields:["source","target"],as:["source","target"]}]}],projections:[],scales:[{name:"labelSizeScale",zero:!1,domain:{signal:"sizeLabelDom"},range:{signal:"sizeLabelRange"}},{name:"vertexSizeScale",zero:!1,domain:{signal:"sizeVertexDom"},range:{signal:"sizeVertexRange"}},{name:"xscaleC2",zero:!1,domain:{signal:"xdomC2"},range:{signal:"xrange"}},{name:"yscaleC2",zero:!1,domain:{signal:"ydomC2"},range:{signal:"yrange"}},{name:"xscale",zero:!1,domain:{signal:"xdom"},range:{signal:"xrange"}},{name:"yscale",zero:!1,domain:{signal:"ydom"},range:{signal:"yrange"}},{name:"xscaleC",zero:!1,domain:{signal:"xdomContainment"},range:{signal:"xrange"}},{name:"yscaleLabel",zero:!1,domain:{signal:"ydomLabelOffset"},range:{signal:"yrange"}},{name:"yscaleC",zero:!1,domain:{signal:"ydomContainment"},range:{signal:"yrange"}}],marks:[{type:"symbol",from:{data:"vertices"},encode:{enter:{size:{field:"vertexSize"},tooltip:{value:""},fill:{field:"color"},shape:{field:"vertexShape"},opacity:{field:"visible"},stroke:{value:"white"},strokeWidth:{value:2.5},strokeOpacity:{value:0}},update:{size:{signal:"min(datum.vertexSize,scale('vertexSizeScale',datum.vertexSize))"},x:{field:"x",scale:"xscale"},y:{field:"y",scale:"yscale"}}},zindex:1},{type:"rect",from:{data:"rects"},encode:{enter:{fill:{value:"#ffffff"},stroke:{value:"#000000"}},update:{x:{field:"x",scale:"xscale"},y:{field:"y",scale:"yscale"},width:{field:"w",scale:"xscaleC"},height:{field:"h",scale:"yscaleC"},blend:{value:"exclusion"},cornerRadius:{value:"35"},strokeWidth:{value:"2"}}}},{type:"path",interactive:!1,from:{data:"edges"},encode:{enter:{stroke:{field:"color"}},update:{path:{signal:"'M'+ scale('xscale',substring(split(datum.lp,',')[0],1)) + ',' + scale('yscale',split(split(datum.lp,',')[1],'C')[0]) + 'C' + scale('xscale',split(split(datum.lp,',')[1],'C')[1]) + ',' + scale('yscale',split(split(datum.lp,',')[2],' ')[0]) + ' '+ scale('xscale',split(split(datum.lp,',')[2],' ')[1]) + ',' + scale('yscale',split(split(datum.lp,',')[3],' ')[0]) + ','  + scale('xscale',split(split(datum.lp,',')[3],' ')[1])  +',' + scale('yscale',split(datum.lp,',')[4]) "}}}},{type:"path",interactive:!1,from:{data:"edges2"},encode:{enter:{stroke:{field:"color"}},update:{path:{signal:" 'M'+ scale('xscale',datum.source.x) + ',' + scale('yscale',datum.source.y) + 'L' + scale('xscale',datum.target.x) + ',' + scale('yscale',datum.target.y)"}}}}]};class _e{constructor(e,t,i,s){this.properties=s,this.drawingHeight=Math.max(e,this.properties.heightDrawingDIV),this.drawingWidth=Math.max(t+this.properties.widthRightPadding,this.properties.withDrawingDIV),this.darkMode=i,this.initializeLabelParameter()}initializeLabelParameter(){this.labelEnabled=!0,this.labelSize=this.properties.vertexLabelSize,this.labelFill=this.darkMode?"#fff":"#000"}toggleLabelEnabled(e){this.labelEnabled=!this.labelEnabled}exportSpezificationAnimation(e,t){let i=e;i.width=this.drawingWidth,i.height=this.drawingHeight;let s="";switch(t.angle){case 0:case 90:s="horizontal";break;default:s="vertical"}return i.data[1].transform[1].orient=s,e.marks[2].encode.enter.stroke={field:"color"},this.darkMode?(e.marks[1].encode.enter.fill={value:"#000000"},e.marks[1].encode.enter.stroke={value:"#ffffff"},e.marks[2].encode.enter.opacity={field:"opacity"},e.marks[3].encode.enter.opacity={field:"opacity"}):(e.marks[2].encode.enter.opacity={value:.5},e.marks[2].encode.enter.strokeOpacity={field:"opacity"},e.marks[3].encode.enter.opacity={value:.5},e.marks[3].encode.enter.strokeOpacity={field:"opacity"}),e.signals[4].value=[1,this.drawingWidth],e.signals[5].value=[this.drawingHeight,1],this.labelEnabled&&(i.marks=[i.marks[1],i.marks[0],i.marks[2],i.marks[3],{type:"text",from:{data:"vertices"},encode:{enter:{fill:{field:"labelColor"}},update:{x:{field:"x"},y:{field:"y"},lineHeight:0,angle:{field:"angle"},dy:{field:"labelOffsetY"},dx:{field:"labelOffsetX"},fontSize:{value:this.labelSize},fillOpacity:{value:1},strokeOpacity:{value:1},align:{value:"center"}}},zindex:2}]),i}exportSpezification(e,t){let i=e;i.width=this.drawingWidth,i.height=this.drawingHeight;let s="";switch(t.angle){case 0:case 90:s="horizontal";break;default:s="vertical"}return i.data[1].transform[1].orient=s,e.marks[2].encode.enter.stroke={field:"color"},this.darkMode?(e.marks[1].encode.enter.fill={value:"#000000"},e.marks[1].encode.enter.stroke={value:"#ffffff"},e.marks[2].encode.enter.opacity={field:"opacity"},e.marks[3].encode.enter.opacity={field:"opacity"}):(e.marks[2].encode.enter.opacity={value:.5},e.marks[2].encode.enter.strokeOpacity={field:"opacity"},e.marks[3].encode.enter.opacity={value:.5},e.marks[3].encode.enter.strokeOpacity={field:"opacity"}),e.signals[4].value=[1,this.drawingWidth],e.signals[5].value=[this.drawingHeight,1],this.labelEnabled&&(i.marks=[i.marks[1],i.marks[0],i.marks[2],i.marks[3],{type:"text",from:{data:"vertices"},encode:{enter:{fill:{field:"labelColor"},text:{field:"label"}},update:{text:{signal:"if(scale('labelSizeScale',20)< 8,' ',datum.label)"},x:{field:"x",scale:"xscale"},y:{field:"y",scale:"yscale"},angle:{field:"angle"},baseline:{value:"line-top"},dy:{signal:"if(datum.labelOffsetY == -7,-7,if(datum.labelOffsetY =="+this.properties.oneLineLabelOffset+"|| datum.labelOffsetY =="+this.properties.rootExplorationOneLineLabelOffset+" ,-sqrt(scale('vertexSizeScale',datum.vertexSize)),-14-sqrt(scale('vertexSizeScale',datum.vertexSize))))"},fillOpacity:{value:1},strokeOpacity:{value:1},align:{value:"center"}}},zindex:2}]),i}}class x{constructor(e,t){this.vertices=t.slice(0),this.createVertexInducedMap(e,t),this.numVertices=t.length,this.outDegree=new Map,this.inDegree=new Map,this.vertexVisible=new Map,this.induceEdges(t,e.outDegree,this.outDegree),this.induceEdges(t,e.inDegree,this.inDegree),this.induceVertexArrays(t,e),this.vertexType=new Map,this.vertexLabel=new Map,this.vertexColor=new Map,this.induceDataContainer(t,e.vertexType,this.vertexType),this.induceDataContainer(t,e.vertexLabel,this.vertexLabel),this.induceDataContainer(t,e.vertexVisible,this.vertexVisible),this.induceDataContainer(t,e.vertexColor,this.vertexColor),this.organ=e.organ,this.IDtoOntologyType=new Map,this.IDtoOntologyID=new Map,this.induceDataContainer(t,e.IDtoOntologyType,this.IDtoOntologyType),this.induceDataContainer(t,e.IDtoOntologyID,this.IDtoOntologyID),this.vertexSize=new Map,this.induceDataContainer(t,e.vertexSize,this.vertexSize)}addVertex(e,t,i,s,r,n){switch(e){case f.AS:this.verticesAS.push(t),this.numVerticesAS+=1;break;case f.CT:this.verticesCT.push(t),this.numVerticesCT+=1;break;case f.BM:this.verticesBM.push(t),this.numVerticesBM+=1}this.vertices.push(t),this.vertexType[t]=e,this.vertexColor[t]=i,this.vertexVisible[t]=1,this.vertexSize[t]=r,this.vertexLabel[t]=n,this.numVertices+=1}createVertexInducedMap(e,t){this.vertexInduced=new Map,e.vertices.forEach(i=>{this.vertexInduced[i]=!!t.includes(i)})}induceVertexArrays(e,t){this.verticesAS=[],this.verticesCT=[],this.verticesBM=[],e.forEach(i=>{switch(t.vertexType[i]){case f.AS:this.verticesAS.push(i);break;case f.CT:this.verticesCT.push(i);break;case f.BM:this.verticesBM.push(i)}}),this.numVerticesAS=this.verticesAS.length,this.numVerticesCT=this.verticesCT.length,this.numVerticesBM=this.verticesBM.length}induceEdges(e,t,i){e.forEach(s=>{if(s in t){let r=[];t[s].forEach(n=>{this.vertexInduced[n]&&r.push(n)}),r.length>0&&(i[s]=r)}})}induceDataContainer(e,t,i){e.forEach(s=>{i[s]=t[s]})}merge(e){let t=e.vertices;t.forEach(i=>{i in e.outDegree&&(this.outDegree[i]=e.outDegree[i]),i in e.inDegree&&(this.inDegree[i]=e.inDegree[i])}),this.induceDataContainer(t,e.vertexType,this.vertexType),this.induceDataContainer(t,e.vertexLabel,this.vertexLabel),this.induceDataContainer(t,e.vertexVisible,this.vertexVisible),this.induceDataContainer(t,e.vertexColor,this.vertexColor),this.induceDataContainer(t,e.IDtoOntologyType,this.IDtoOntologyType),this.induceDataContainer(t,e.IDtoOntologyID,this.IDtoOntologyID),this.induceDataContainer(t,e.vertexSize,this.vertexSize),t.forEach(i=>{switch(e.vertexType[i]){case f.AS:this.verticesAS.push(i),this.numVerticesAS+=1;break;case f.CT:this.verticesCT.push(i),this.numVerticesCT+=1;break;case f.BM:this.verticesBM.push(i),this.numVerticesBM+=1}this.vertices.push(i)}),this.numVerticesAS=this.verticesAS.length,this.numVerticesCT=this.verticesCT.length,this.numVerticesBM=this.verticesBM.length}}var y=S(817);class qe{constructor(e,t){t.rotate&&(console.log("ROTATION INTERNAL",t.rotateAngle),90==t.rotateAngle?this.apply90Rot(e,90):180==t.rotateAngle?this.applyXYSwap(e):270==t.rotateAngle&&(this.applyXYSwap(e),this.apply90Rot(e,270)),this.updateDimensions(e))}applyXYSwap(e){Object.keys(e).forEach(t=>{let i=e[parseFloat(t)];i=new y.S(i.y+20,i.x+20),e[parseFloat(t)]=i})}translateMap(e){Object.keys(e).forEach(t=>{e[parseFloat(t)]=this.translate(e[parseFloat(t)],Math.abs(this.minX),Math.abs(this.minY))})}translate(e,t,i){return new y.S(e.x+t,e.y+i)}scaleXY(e,t){this.matrix11=e,this.matrix12=0,this.matrix21=0,this.matrix22=t}rotate(e){let t=e*Math.PI/180;this.matrix11=Math.cos(t),this.matrix12=-Math.sin(t),this.matrix21=Math.sin(t),this.matrix22=Math.cos(t)}calculateMap(e){return new y.S(this.matrix11*e.x+this.matrix21*e.y,this.matrix12*e.x+this.matrix22*e.y)}apply90Rot(e,t){this.rotate(t),Object.keys(e).forEach(s=>{let r=e[parseFloat(s)];r=this.calculateMap(r),e[parseFloat(s)]=r}),this.updateDimensions(e),Object.keys(e).forEach(s=>{let r=e[parseFloat(s)],n=20,a=20;this.minX<0&&(n+=Math.abs(this.minX)),this.minY<0&&(a+=Math.abs(this.minY)),r=this.translate(r,n,a),e[parseFloat(s)]=new y.S(r.y,r.x)})}applyMap(e){Object.keys(e).forEach(t=>{e[parseFloat(t)]=this.calculateMap(e[parseFloat(t)])})}updateDimensions(e){let t=Number.MAX_VALUE,i=Number.MIN_VALUE,s=Number.MAX_VALUE,r=Number.MIN_VALUE;Object.keys(e).forEach(n=>{let a=e[n];a.x<t&&(t=a.x),a.x>i&&(i=a.x),a.y<s&&(s=a.y),a.y>r&&(r=a.y)}),this.minX=t,this.maxX=i,this.minY=s,this.maxY=r}}class _{constructor(e,t,i){this.graph=e,this.drawing=new Map,this.highlightedEdge=new Map,this.rects=[],this.labelPosition=new Map,this.graph.vertices.forEach(s=>this.labelPosition[s]="0"),this.angle=t.rotateAngle,this.rotate=t.rotate,this.rotation=t,this.properties=i}initializeHighlights(e,t){e.vertices.forEach(i=>{i in e.outDegree&&e.outDegree[i].forEach(s=>{let r=String(i)+"|"+String(s);t[r]=!1})})}rotateAngle(e,t){t.leaves.forEach(i=>{this.labelPosition[i]=e,i in this.graph.inDegree&&this.graph.inDegree[i].forEach(s=>this.labelPosition[s]=e)}),this.graph.verticesCT.forEach(i=>this.labelPosition[i]=e),this.graph.verticesBM.forEach(i=>this.labelPosition[i]=e)}calculateWidthHeight(){this.maximumWidth=0,this.maximumHeight=0,this.graph.vertices.forEach(e=>{this.drawing[e].y>this.maximumHeight&&(this.maximumHeight=this.drawing[e].y),this.drawing[e].x>this.maximumWidth&&(this.maximumWidth=this.drawing[e].x)}),this.maximumHeight+=Math.max(this.offsetIncrementAS,this.offsetIncrementBM,this.offsetIncrementCT)}calculateDepth(){let e=new x(this.graph,this.graph.verticesAS),t=null;return e.vertices.forEach(i=>{i in e.inDegree||(t=i)}),this.calculateDepthWorker(e,t)}calculateDepthWorker(e,t){if(t in e.outDegree){let i=Number.NEGATIVE_INFINITY;return e.outDegree[t].forEach(s=>{let r=this.calculateDepthWorker(e,s);r>i&&(i=r)}),i+1}return 1}calculateParameter(){this.depth=this.calculateDepth()-1,0==this.rotation.rotateAngle||90==this.rotation.rotateAngle?(this.depthMultiplier=0==this.depth?this.properties.totalWidth/3:this.properties.totalWidth/3/this.depth,this.offsetCTBM=this.properties.totalWidth/3,this.xPositionCT=this.properties.totalWidth-this.offsetCTBM,this.xPositionBM=this.properties.totalWidth):(this.depthMultiplier=0==this.depth?.9*this.properties.heightDrawingDIV/3:.9*this.properties.heightDrawingDIV/3/this.depth,this.offsetCTBM=.9*this.properties.heightDrawingDIV/3,this.xPositionCT=.9*this.properties.heightDrawingDIV-this.offsetCTBM,this.xPositionBM=.9*this.properties.heightDrawingDIV),this.class==M.Containment?(this.offsetIncrementAS=this.properties.offsetIncrementTwoLines,this.offsetIncrementCT=2*this.offsetIncrementAS,this.offsetIncrementBM=this.properties.offsetIncrementTwoLines):(this.offsetIncrementCT=this.properties.offsetIncrementTwoLines,this.offsetIncrementBM=this.properties.offsetIncrementTwoLines,this.offsetIncrementAS=this.properties.offsetIncrementTwoLines)}feasibleClippingCT(){return this.graph.verticesCT.length>0&&this.graph.verticesBM.length>0}applyLinearMap(e,t){let i=new qe(this.drawing,e);e.rotate&&(this.maximumHeight=i.maxY+30,this.maximumWidth=i.maxX+30),(e.rotate&&180==e.rotateAngle||e.rotate&&270==e.rotateAngle)&&this.rotateAngle(-90,t)}}var M=(()=>{return(l=M||(M={}))[l.Partial=0]="Partial",l[l.Subgraph=1]="Subgraph",l[l.Exploration=2]="Exploration",l[l.Containment=3]="Containment",M;var l})();class W{constructor(e,t,i){this.graph=e,this.layout=t,this.properties=i,this.graphStyle=new _e(t.maximumHeight,t.maximumWidth,!0,i),this.vertexPosition=t.drawing}exportSpecification(e){let a,t=JSON.parse(JSON.stringify(Ue)),i=[],s=[],r=[],n=[];return a=this.graphStyle.darkMode?"white":"black",this.applyLayoutSpecifics(n),this.processGraph(i,s,r,a),t.data[0].values=i,t.data[1].values=s,t.data[2].values=n,t.data[3].values=r,e?this.graphStyle.exportSpezificationAnimation(t,this.layout):this.graphStyle.exportSpezification(t,this.layout)}applyLayoutSpecifics(e){switch(this.layout.class){case M.Partial:case M.Subgraph:case M.Exploration:break;case M.Containment:this.processContainment(e)}}formatLabelTwoLines(e,t){let i=e.vertexLabel[t];if("string"==typeof i){let s=i.split(" "),r="",n="",a=0;return s.forEach(o=>{a>i.length/3?n=n+" "+o:r=r+" "+o,a+=o.length}),n.length>0?[r,n]:[r]}return i}processContainment(e){this.layout.rects.length>0&&this.layout.rects.forEach(t=>{e.push({x:t.positionX,y:t.positionY,w:t.width,h:t.height})})}processGraph(e,t,i,s){this.graph.vertices.forEach(r=>{r in this.vertexPosition||console.log("IDDDD",r,console.log(this.graph.vertexType[r]));const n=this.vertexPosition[r];let o=this.calculateVertexLabel(r);this.graph.vertexLabel[r]=o;let c,h=this.graph.vertexSize[r];c=this.graphStyle.darkMode?"#fff":"#000",this.layout.class==M.Containment&&(this.graph.vertexType[r]==f.CT||this.graph.vertexType[r]==f.AS)&&"black"==this.graph.vertexColor[r]&&(c=this.graphStyle.darkMode?"#000":"#fff");let m=this.calculateLabelOffset(r),g=this.graph.vertexColor[r];this.graphStyle.darkMode&&"black"==g&&(g="white");let O,z,E=this.graph.vertexVisible[r];switch(O=0==this.layout.rotation.rotateAngle||90==this.layout.rotation.rotateAngle?0:270,this.graph.vertexType[r]){case f.AS:z="Anatomical Structure";break;case f.CT:z="Cell Type";break;case f.BM:z="Biomarker"}e.push({id:r,x:n.x,y:n.y,color:g,label:o,visible:E,labelOffsetX:0,labelOffsetY:m,labelColor:c,vertexSize:h,vertexShape:"circle",vertexType:z,angle:O}),r in this.graph.outDegree&&this.graph.outDegree[r].forEach(Q=>{let $,mt=String(r)+"|"+String(Q);$=this.layout.highlightedEdge[mt]?1:.4,this.graph.vertexType[r]==f.AS&&this.graph.vertexType[Q]==f.AS?t.push({source:r,target:Q,color:s,opacity:$}):i.push({source:r,target:Q,color:s,opacity:$})})})}calculateVertexLabel(e){let t,i=this.graph.vertexLabel[e],s=this.formatLabelTwoLines(this.graph,e);if(this.layout.class===M.Containment)switch(this.graph.vertexType[e]){case f.AS:case f.CT:t=s;break;case f.BM:t=i}else switch(this.graph.vertexType[e]){case f.AS:t=s;break;case f.CT:case f.BM:t=i}return t}calculateLabelOffset(e){let t,i=this.graph.vertexLabel[e];if(null==i)return 0;switch(this.layout.class){case M.Containment:this.graph.vertexType[e]===f.BM?t=this.properties.oneLineLabelOffset:(t=2==i.length?this.properties.twoLineLabelOffset:this.properties.oneLineLabelOffset,"black"==this.graph.vertexColor[e]&&(t=this.properties.collapsedCTLabelOffset));break;case M.Exploration:this.graph.vertexType[e]===f.AS?2==i.length?(t=this.properties.twoLineLabelOffset,this.graph.vertexSize[e]==this.properties.rootExplorationVertexSize&&(t=this.properties.rootExplorationTwoLineLabelOffset)):(t=this.properties.oneLineLabelOffset,this.graph.vertexSize[e]==this.properties.rootExplorationVertexSize&&(t=this.properties.rootExplorationOneLineLabelOffset)):t=this.properties.oneLineLabelOffset;break;default:t=2==i.length?this.properties.twoLineLabelOffset:this.properties.oneLineLabelOffset}return t}}var b=S(951);class Ke{constructor(){this.data=[],this.offset=0}getLength(){return this.data.length-this.offset}isEmpty(){return 0==this.data.length}enqueue(e){this.data.push(e)}dequeue(){if(0!=this.data.length){var e=this.data[this.offset];return 2*++this.offset>=this.data.length&&(this.data=this.data.slice(this.offset),this.offset=0),e}}peek(){return this.data.length>0?this.data[this.offset]:void 0}}class H{constructor(e,t,i){this.graph=e,this.queue=new Ke,this.verticesNEW=[],this.visited=new Array(this.graph.numVertices).fill(!1),this.level=new Array(this.graph.numVertices).fill(-1),this.breathFirstSearch(t,i)}breathFirstSearch(e,t){for(this.visited[e]=!0,this.level[e]=0,this.verticesNEW.push(e),this.queue.enqueue(e);!this.queue.isEmpty();){let i=this.queue.dequeue();i in t&&t[i].forEach(r=>{this.visited[r]||(this.visited[r]=!0,this.level[r]=this.level[i]+1,this.queue.enqueue(r),this.verticesNEW.push(r))})}}createLevels(){let e=[];return this.verticesNEW.forEach(t=>{let i=this.level[t];-1!=i&&void 0!==i&&(void 0===e[i]?e.push([t]):e[i].push(t))}),e}reachable(){let e=[];return this.verticesNEW.forEach(t=>{let i=this.level[t];-1!=i&&void 0!==i&&e.push([t])}),e}}class k{constructor(e){let t=this.calculatePossibleRoots(e),i=new x(e,e.verticesAS);this.leaves=[],t.forEach(s=>{this.worker(s,i)})}worker(e,t){e in t.outDegree?t.outDegree[e].forEach(s=>{this.worker(s,t)}):this.leaves.push(e)}calculatePossibleRoots(e){let t=[];return e.verticesAS.forEach(i=>{i in e.inDegree||t.push(i)}),t}}class L{constructor(e,t,i){this.graph=e,this.fixedVertices=t,this.freeVertices=i,this.fixedIndex=new Map,this.groups=new Map,this.slots=[],this.createIndexMap(t),this.createGroups(e.inDegree),this.createSlots()}createIndexMap(e){for(let t=0;t<e.length;t++)this.fixedIndex[e[t]]=t}createSlots(){for(const[e,t]of Object.entries(this.groups))t.forEach(i=>{this.slots.push(i)})}createGroups(e){this.freeVertices.forEach(t=>{let i=this.medianAssessment(t,e);i in this.groups?this.groups[i].push(t):this.groups[i]=[t]})}medianAssessment(e,t){if(!(e in t))return-1;{let s=[];if(t[e].forEach(r=>{s.push(this.fixedIndex[r])}),s.length>1){s.sort((n,a)=>n-a);let r=Math.floor(s.length/2);return s[r]}if(1==s.length)return s[0]}}}class he{constructor(e,t,i,s,r){this.offsetsX=[],this.offsetIncrementAS=r,this.depthMultiplier=s,this.nextConnnectedComponentOffset=0,this.maximumX=0;let n=new x(e,e.verticesAS),o=new k(e).leaves,h=this.calculatePossibleRoots(e);this.neighbourMAP=new Map;let c=0;o.forEach(p=>{if(p in e.outDegree){let m=0;e.outDegree[p].forEach(g=>m+=t[g].y),m/=e.outDegree[p].length,t[p]=new y.S(i*s+50,m),c=m}else t[p]=new y.S(i*s+50,c+r),c+=r}),this.maintainMinimumDistanceAS(o,t,r),h.forEach(p=>{this.nextYonLayer=[],this.drawLayout(p,0,e,n,t),this.nextConnnectedComponentOffset=this.nextYonLayer[this.nextYonLayer.length-1];let m=(this.nextYonLayer.length-1)*this.depthMultiplier;m>this.maximumX&&(this.maximumX=m)})}calculatePossibleRoots(e){let t=[];return e.verticesAS.forEach(i=>{i in e.inDegree||t.push(i)}),t}drawLayout(e,t,i,s,r){void 0===this.nextYonLayer[t]&&this.nextYonLayer.push(this.nextConnnectedComponentOffset);let a,n=t*this.depthMultiplier+50;if(e in s.outDegree){let o=s.outDegree[e];o.forEach(h=>{this.drawLayout(h,t+1,i,s,r)}),a=1==o.length?r[o[0]].y:(r[o[0]].y+r[o[o.length-1]].y)/2,r[e]=new y.S(n,a)}this.nextYonLayer[t]=this.nextYonLayer[t]+this.offsetIncrementAS}maintainMinimumDistanceAS(e,t,i){if(e.length>0){let s=t[e[0]].y;for(let r=1;r<e.length;r++){let n=e[r],a=e[r-1],o=t[n];if(o.y-s<i){let c=s+i;s=c,t[n]=new y.S(t[a].x,c)}else s=o.y}this.maximumY=s}}}class te{constructor(e,t,i){this.layout=e,this.averageSpacingCT(t,i),this.maintainMinimumDistanceCT(t)}calculateNeighborYMean(e){let t=0;if(e in this.layout.graph.outDegree){let i=0;return this.layout.graph.outDegree[e].forEach(s=>{this.layout.graph.vertexType[s]==f.BM&&1==this.layout.graph.inDegree[s].length&&(t+=this.layout.drawing[s].y,i+=1)}),0!==i?t/i:-1}return-1}averageSpacingCT(e,t){e.forEach(i=>{let s=this.calculateNeighborYMean(i);if(-1==s){let r=new y.S(this.layout.xPositionCT,t+this.layout.offsetIncrementCT);t=r.y,this.layout.drawing[i]=r}else{let r=new y.S(this.layout.xPositionCT,s);t=r.y,this.layout.drawing[i]=r}})}maintainMinimumDistanceCT(e){if(e.length>0){let t=this.layout.drawing[e[0]].y;for(let i=1;i<e.length;i++){let s=e[i],r=e[i-1],n=this.layout.drawing[s];if(n.y-t<this.layout.offsetIncrementCT){let o=t+this.layout.offsetIncrementCT;t=o,this.layout.drawing[s]=new y.S(this.layout.drawing[r].x,o)}else t=n.y}this.finalOffset=t+this.layout.offsetIncrementCT}}}class Qe extends _{constructor(e,t,i,s){super(e,i,s),this.class=M.Partial;let r=new k(e),n=r.leaves;this.calculateDepth(),this.calculateParameter();let o=new L(e,n,e.verticesCT);this.slotsCT=o.slots;let h=new L(e,this.slotsCT,e.verticesBM);if(this.slotsBM=h.slots,this.drawCellTypes(this.slotsCT),this.graph.verticesBM.length>0){let p=this.calculateMinY();this.slotsBM.forEach(g=>{let E=new y.S(this.xPositionBM,p);p+=this.offsetIncrementBM,this.drawing[g]=E}),new te(this,this.slotsCT,this.offsetIncrementCT)}new he(e,this.drawing,this.depth,this.depthMultiplier,this.offsetIncrementAS),this.calculateWidthHeight(),this.applyLinearMap(i,r),this.updateHighlights(t),console.log(this.graph.vertices),console.log(this.graph.outDegree)}updateHighlights(e){e in this.graph.outDegree&&this.graph.outDegree[e].forEach(t=>{this.updateHighlights(t);let i=String(e)+"|"+String(t);this.highlightedEdge[i]=1})}calculateMinY(){let e=Number.POSITIVE_INFINITY;return this.graph.verticesBM.forEach(t=>{t in this.graph.inDegree&&this.graph.inDegree[t].forEach(i=>{this.drawing[i].y<e&&(e=this.drawing[i].y)})}),e}calculateRoot(e){let t=null;return e.vertices.forEach(i=>{i in e.inDegree||(t=i)}),t}drawCellTypes(e){let t=this.properties.heightTopPadding;e.forEach(i=>{let s=new y.S(this.xPositionCT,t);t+=this.offsetIncrementCT,this.drawing[i]=s})}drawBiomarkers(e){let t=this.properties.heightTopPadding;e.forEach(i=>{let s=new y.S(this.xPositionBM,t);t+=this.offsetIncrementBM,this.drawing[i]=s})}}class ie{constructor(e,t,i,s,r){this.drawing=e,this.verticesToMove=i,this.ticks=r,this.animation=[];for(let n=1;n<r+1;n++){let a=new Map,o=1/r*n;Object.keys(e).forEach(h=>{a[h]=this.drawing[h]});for(let h=0;h<t.length;h++){let c=t[h],p=s[h],m=new y.S(c.x*(1-o)+p.x*o,c.y*(1-o)+p.y*o);a[i[h]]=m}this.animation.push(a)}}}class q{constructor(e){this.dummyID=-9e6,this.leafMap=new Map;let t=new x(e,e.verticesAS);t.vertices.forEach(s=>this.leafMap[s]=!1);let i=this.calculateRoot(t);this.leafWorker(i,t),this.postOrder(i,e)}calculateRoot(e){let t=null;return e.vertices.forEach(i=>{i in e.inDegree||(t=i)}),t}leafWorker(e,t){e in t.outDegree?t.outDegree[e].forEach(i=>{this.leafWorker(i,t)}):this.leafMap[e]=!0}postOrder(e,t){if(e in t.outDegree){let i=[];t.outDegree[e].forEach(s=>{switch(t.vertexType[s]){case f.AS:this.postOrder(s,t);break;case f.CT:this.leafMap[e]||i.push(s)}}),i.length>0&&this.extendGraph(t,e,i)}}extendGraph(e,t,i){this.dummyID-=1,e.verticesAS.push(this.dummyID),e.vertices.push(this.dummyID),e.numVertices+=1,e.numVerticesAS+=1,e.vertexType[this.dummyID]=f.AS,e.vertexColor[this.dummyID]="red",e.vertexLabel[this.dummyID]="",e.vertexVisible[this.dummyID]=0,e.vertexSize[this.dummyID]=300,i.forEach(s=>{this.removeByValue(s,e.outDegree[t]),this.removeByValue(t,e.inDegree[s]),e.inDegree[s].push(this.dummyID)}),e.outDegree[this.dummyID]=i,e.outDegree[t].push(this.dummyID),e.inDegree[this.dummyID]=[t]}removeByValue(e,t){let i=t.indexOf(e);-1!=i&&t.splice(i,1)}}class ce{constructor(e,t,i,s){this.sourceID=e,this.middleID=t,this.targetID=i,this.endpointID=s,this.edge={source:e,target:i}}}class K{constructor(e){this.bends=[],this.bendCount=-1,this.depth=Number.NEGATIVE_INFINITY;let t=new x(e,e.verticesAS);this.calculatePossibleRoots(e).forEach(s=>{this.treeAugmentation(s,e,t)}),this.processBends(e,t)}treeAugmentation(e,t,i){let r=new H(i,e,i.outDegree).createLevels();this.depth<r.length&&(this.depth=r.length);for(let n=0;n<r.length-1;n++)r[n].forEach(o=>{if(!(o in i.outDegree)){let h=o;if(o in t.inDegree){let c=t.inDegree[o][0],p=[];c in i.outDegree&&(i.outDegree[c].forEach(g=>{g!=o&&p.push(g)}),i.outDegree[c]=p);let m=[];for(let g=n+1;g<r.length;g++)i.outDegree[this.bendCount]=[h],m.push(this.bendCount),h=this.bendCount,this.bendCount=this.bendCount-1;this.bends.push(new ce(c,m,o,o)),c in i.outDegree&&i.outDegree[c].push(h)}}})}processBends(e,t){this.bends.forEach(i=>{let s=i.middleID;s.forEach(n=>{e.vertices.push(n),e.verticesAS.push(n),e.numVertices+=1,e.numVerticesAS+=1,e.vertexType[n]=f.AS,e.vertexColor[n]="red",e.vertexLabel[n]=" ",e.vertexVisible[n]=0,e.vertexSize[n]=300});let r=i.targetID;s.forEach(n=>{n in e.outDegree?e.outDegree[n].push(r):e.outDegree[n]=[r],r in e.inDegree?e.inDegree[r].push(n):e.inDegree[r]=[n],r=n}),e.inDegree[s[s.length-1]]=[i.sourceID],e.outDegree[i.sourceID].push(s[s.length-1]),this.removeByValue(i.targetID,e.outDegree[i.sourceID]),this.removeByValue(i.sourceID,e.inDegree[i.targetID])})}removeByValue(e,t){let i=t.indexOf(e);t.splice(i,1)}calculatePossibleRoots(e){let t=[];return e.verticesAS.forEach(i=>{i in e.inDegree||t.push(i)}),t}}class ue{constructor(e){this.graph=e,this.treeAS=new x(e,e.verticesAS),this.counter=1,this.subtreeMap=new Map;let t=this.calculateRoot();this.calculateSubtreeMap(t),this.artificialCTID=-2e5,this.artificialBMID=-75e4,this.replicateCTBM()}replicateCTBM(){this.graph.verticesCT.forEach(e=>{if(e in this.graph.inDegree){let t=new Map;this.graph.inDegree[e].forEach(s=>{let r=this.subtreeMap[s];r in t?t[r].push(s):t[r]=[s]});let i=!0;for(const[s,r]of Object.entries(t))i?i=!1:this.augment(e,r)}})}augment(e,t){this.graph.vertices.push(this.artificialCTID),this.graph.verticesCT.push(this.artificialCTID),this.graph.numVertices+=1,this.graph.numVerticesCT+=1,this.graph.vertexType[this.artificialCTID]=f.CT,this.graph.vertexVisible[this.artificialCTID]=1,this.graph.vertexSize[this.artificialCTID]=this.graph.vertexSize[e],this.graph.vertexLabel[this.artificialCTID]=this.graph.vertexLabel[e],this.graph.vertexColor[this.artificialCTID]=this.graph.vertexColor[e],this.graph.IDtoOntologyType[this.artificialCTID]=this.graph.IDtoOntologyType[e],this.graph.IDtoOntologyID[this.artificialCTID]=this.graph.IDtoOntologyID[e],t.forEach(i=>{this.graph.inDegree[this.artificialCTID]=[i],this.graph.outDegree[i].push(this.artificialCTID),this.removeByValue(i,this.graph.inDegree[e]),this.removeByValue(e,this.graph.outDegree[i])}),e in this.graph.outDegree&&this.augmentBM(this.graph.outDegree[e]),this.artificialCTID-=1}augmentBM(e){let t=[];for(let i=0;i<e.length;i++){let s=e[i];t.push(this.artificialBMID),this.graph.vertices.push(this.artificialBMID),this.graph.verticesBM.push(this.artificialBMID),this.graph.vertexVisible[this.artificialBMID]=1,this.graph.vertexColor[this.artificialBMID]=this.graph.vertexColor[s],this.graph.IDtoOntologyType[this.artificialBMID]=this.graph.IDtoOntologyType[s],this.graph.IDtoOntologyID[this.artificialBMID]=this.graph.IDtoOntologyID[s],this.graph.vertexSize[this.artificialBMID]=this.graph.vertexSize[s],this.graph.numVertices+=1,this.graph.numVerticesBM+=1,this.graph.vertexType[this.artificialBMID]=f.BM,this.graph.vertexLabel[this.artificialBMID]=this.graph.vertexLabel[s],this.artificialBMID-=1}t.forEach(i=>{i in this.graph.inDegree?this.graph.inDegree[i].push(this.artificialCTID):this.graph.inDegree[i]=[this.artificialCTID],this.artificialCTID in this.graph.outDegree?this.graph.outDegree[this.artificialCTID].push(i):this.graph.outDegree[this.artificialCTID]=[i]})}removeByValue(e,t){let i=t.indexOf(e);-1!=i&&t.splice(i,1)}calculateRoot(){let e=-1;return this.treeAS.vertices.forEach(t=>{t in this.treeAS.inDegree||(e=t)}),e}calculateSubtreeMap(e){return e in this.treeAS.outDegree?(this.treeAS.outDegree[e].forEach(t=>{this.calculateSubtreeMap(t)||(this.counter+=1)}),!1):(this.subtreeMap[e]=this.counter,!0)}}class pe{constructor(e){let t=new x(e,e.verticesAS),i=this.calculateRoot(t),s=new k(e),r=new L(e,s.leaves,e.verticesCT);this.slotsCT=r.slots,this.slotIndexMap=new Map,this.calculateIndexMap(),this.hasLeaf=new Map,this.calculateLeafMap(i,e,t),this.heuristicAS=new Map,this.calculateASHeuristic(i,e,t),this.balancing(i,e,t)}calculateIndexMap(){for(let e=0;e<this.slotsCT.length;e++)this.slotIndexMap[this.slotsCT[e]]=e}balancing(e,t,i){if(e in i.outDegree){let s=[],r=[],n=!1;return i.outDegree[e].forEach(a=>{this.hasLeaf[a]?s.push(a):r.push(a),n=this.balancing(a,t,i)}),n?this.leafProcessing(e,t):t.outDegree[e].sort((a,o)=>this.heuristicAS[a]-this.heuristicAS[o]),!1}return!0}leafProcessing(e,t){let i=[],s=[];t.outDegree[e].forEach(r=>{this.hasLeaf[r]?i.push(r):s.push(r)}),i.sort((r,n)=>this.medianSlotHeuristic(r,t)-this.medianSlotHeuristic(n,t)),t.outDegree[e]=i.concat(s)}medianSlotHeuristic(e,t){let i=[];return t.outDegree[e].forEach(s=>{i.push(this.slotIndexMap[s])}),this.calculateMedian(i)}calculateMedian(e){return 1==e.length?e[0]:0==e.length?0:(e.sort((i,s)=>i-s),e[Math.floor(e.length/2)])}calculateY(e,t,i){let s=0;return e.outDegree[i].forEach(r=>s+=t[r].y),s/e.outDegree[i].length}calculateASHeuristic(e,t,i){if(e in i.outDegree){let s=0;i.outDegree[e].forEach(r=>{this.calculateASHeuristic(r,t,i),s+=this.heuristicAS[r]}),this.heuristicAS[e]=s}else this.heuristicAS[e]=e in t.outDegree?-10:1}calculateRoot(e){let t=null;return e.vertices.forEach(i=>{i in e.inDegree||(t=i)}),t}calculateLeafMap(e,t,i){if(e in i.outDegree){let s=!1;i.outDegree[e].forEach(r=>{this.calculateLeafMap(r,t,i),this.hasLeaf[r]&&(s=!0)}),this.hasLeaf[e]=s}else this.hasLeaf[e]=e in t.outDegree}}class fe{constructor(e){this.graph=e,this.subtreeMap=new Map,this.treeAS=new x(e,e.verticesAS),this.counter=1;let t=this.calculateRoot();this.calculateSubtreeMap(t),this.artificialBMID=-85e4,this.replicateBM()}calculateRoot(){let e=-1;return this.treeAS.vertices.forEach(t=>{t in this.treeAS.inDegree||(e=t)}),e}calculateSubtreeMap(e){return e in this.treeAS.outDegree?(this.treeAS.outDegree[e].forEach(t=>{this.calculateSubtreeMap(t)||(this.counter+=1)}),!1):(this.subtreeMap[e]=this.counter,e in this.graph.outDegree&&this.graph.outDegree[e].forEach(t=>this.subtreeMap[t]=this.counter),!0)}replicateBM(){this.graph.verticesBM.forEach(e=>{if(e in this.graph.inDegree){let t=new Map;this.graph.inDegree[e].forEach(s=>{let r=this.subtreeMap[s];r in t?t[r].push(s):t[r]=[s]});let i=!0;for(const[s,r]of Object.entries(t))i?i=!1:this.augment(e,r)}})}augment(e,t){this.graph.vertices.push(this.artificialBMID),this.graph.verticesBM.push(this.artificialBMID),this.graph.numVertices+=1,this.graph.numVerticesBM+=1,this.graph.vertexType[this.artificialBMID]=f.BM,this.graph.vertexLabel[this.artificialBMID]=this.graph.vertexLabel[e],this.graph.IDtoOntologyType[this.artificialBMID]=this.graph.IDtoOntologyType[e],this.graph.IDtoOntologyID[this.artificialBMID]=this.graph.IDtoOntologyID[e],this.graph.vertexSize[this.artificialBMID]=this.graph.vertexSize[e],this.graph.vertexVisible[this.artificialBMID]=1,this.graph.vertexColor[this.artificialBMID]=this.graph.vertexColor[e],t.forEach(i=>{this.graph.outDegree[i].push(this.artificialBMID),this.artificialBMID in this.graph.inDegree?this.graph.inDegree[this.artificialBMID].push(i):this.graph.inDegree[this.artificialBMID]=[i]}),t.forEach(i=>{this.removeByValue(i,this.graph.inDegree[e]),this.removeByValue(e,this.graph.outDegree[i])}),this.artificialBMID-=1}removeByValue(e,t){let i=t.indexOf(e);-1!=i&&t.splice(i,1)}}class $e{constructor(e,t){this.source=e,this.target=t}}class se{constructor(e,t,i){let r=new L(t,e,t.verticesBM).slots;this.createIndexMapCT(e),this.createIndexMapBMCT(e,r,t.inDegree),this.calculateReplacements(e,r,i,t.inDegree,t.outDegree),this.update(t),this.calculateSlots(r)}calculateSlots(e){this.newSlotsBM=e.slice(0),this.replacements.forEach(t=>{this.newSlotsBM.push(t.newBM)})}deepClone(e,t,i,s,r){i.verticesAS.forEach(n=>{n in t&&(e[n]=t[n].slice(0))}),s.forEach(n=>{n in t&&(e[n]=t[n].slice(0))}),r.forEach(n=>{n in t&&(e[n]=t[n].slice(0))})}update(e){this.replacements.forEach(t=>{e.vertices.push(t.newBM),e.verticesBM.push(t.newBM),e.numVertices+=1,e.numVerticesBM+=1,e.vertexType[t.newBM]=f.BM,e.vertexLabel[t.newBM]=e.vertexLabel[t.originalBM],e.IDtoOntologyType[t.newBM]=e.IDtoOntologyType[t.originalBM],e.IDtoOntologyID[t.newBM]=e.IDtoOntologyID[t.originalBM],e.vertexSize[t.newBM]=e.vertexSize[t.originalBM],e.vertexVisible[t.newBM]=1,e.vertexColor[t.newBM]=e.vertexColor[t.originalBM],e.inDegree[t.newBM]=[t.originalCT],e.outDegree[t.originalCT].push(t.newBM),this.removeByValue(t.originalCT,e.inDegree[t.originalBM]),this.removeByValue(t.originalBM,e.outDegree[t.originalCT])})}createIndexMapCT(e){this.indexMapCT=new Map;for(let t=0;t<e.length;t++)this.indexMapCT[e[t]]=t}createIndexMapBMCT(e,t,i){this.indexMapBMCT=new Map,t.forEach(s=>{this.indexMapBMCT[s]=s in i?this.calculateCTGroupMean(i[s]):Number.POSITIVE_INFINITY})}calculateCTGroupMean(e){if(e.length>0){let t=0;return e.forEach(i=>{t+=this.indexMapCT[i]}),t/e.length}return 0}replacementEdgeHierarchy(e,t){let i=[];return e.forEach(s=>{s in t&&t[s].forEach(n=>{i.push(new $e(s,n))})}),i.sort((s,r)=>Math.abs(this.indexMapCT[r.source]-this.indexMapBMCT[r.target])-Math.abs(this.indexMapCT[s.source]-this.indexMapBMCT[s.target])),i}calculateReplacements(e,t,i,s,r){this.replacements=[],this.replacementsMap=new Map,t.forEach(o=>{this.replacementsMap[o]=o in s?s[o].length:0});let n=-1e5,a=this.replacementEdgeHierarchy(e,r);if(i>0){let o=a.length*(i/100),h=0;a.forEach(c=>{this.replacementsMap[c.target]>1&&h<o&&(this.replacements.push(new Ze(c.source,c.target,n)),this.replacementsMap[c.target]=this.replacementsMap[c.target]-1,n-=1,h+=1)})}}removeByValue(e,t){let i=t.indexOf(e);t.splice(i,1)}}class Ze{constructor(e,t,i){this.originalCT=e,this.originalBM=t,this.newBM=i}}class Je{constructor(e,t,i,s,r,n,a){this.drawing=new Map,this.graph=new x(e,e.vertices),this.biomarkerX=s,this.cellTypeX=r,this.angleThreshold=55,this.feasible=!0,this.augment(i,t),this.draw(a,n),this.isFeasible()}isFeasible(){this.graph.verticesCT.forEach(e=>{e in this.graph.outDegree&&this.graph.outDegree[e].forEach(t=>{this.calculateAngle(this.drawing[e],this.drawing[t])>this.angleThreshold&&(this.feasible=!1)})})}augment(e,t){this.slotsCT=e;let i=new L(this.graph,this.slotsCT,this.graph.verticesBM);this.slotsBM=i.slots,new se(this.slotsCT,this.graph,t);let r=new L(this.graph,this.slotsCT,this.graph.verticesBM);this.slotsBM=r.slots}draw(e,t){let i=0;this.slotsBM.forEach(s=>{let r=new y.S(this.biomarkerX,i);i+=e,this.drawing[s]=r}),this.averageSpacingCT(this.slotsCT,0,t),this.maintainMinimumDistanceCT(this.slotsCT,t)}calculateNeighborYMean(e){let t=0;if(e in this.graph.outDegree){let i=0;return this.graph.outDegree[e].forEach(s=>{this.graph.vertexType[s]==f.BM&&1==this.graph.inDegree[s].length&&(t+=this.drawing[s].y,i+=1)}),0!==i?t/i:-1}return-1}averageSpacingCT(e,t,i){e.forEach(s=>{let r=this.calculateNeighborYMean(s);if(-1==r){let n=new y.S(this.cellTypeX,t+i);t=n.y,this.drawing[s]=n}else{let n=new y.S(this.cellTypeX,r);t=n.y,this.drawing[s]=n}})}maintainMinimumDistanceCT(e,t){if(e.length>0){let i=this.drawing[e[0]].y;for(let s=1;s<e.length;s++){let r=e[s],n=e[s-1],a=this.drawing[r];if(a.y-i<t){let h=i+t;i=h,this.drawing[r]=new y.S(this.drawing[n].x,h)}else i=a.y}}}calculateAngle(e,t){let i=Math.atan2(t.y-e.y,t.x-e.x)*(180/Math.PI);return Math.abs(i)}calculateLengthEdge(e,t){return Math.sqrt((t.x-e.x)*(t.x-e.x)+(t.y-e.y)*(t.y-e.y))}}class ge{constructor(e,t,i,s,r,n){this.graph=e,this.binarySearch(t,i,s,r,n)}binarySearch(e,t,i,s,r){let n=0,a=100;for(;n<=a;){let o=Math.floor(n+(a-n)/2);if(a==o)break;new Je(this.graph,o,e,t,i,s,r).feasible?a=o:n=o+1}this.parameterReplication=a}}class et extends F{constructor(e){super(e,"Partial"),this.previousDrawing=new Map,this.frames=10,this.frameTime=800}renderRestoreGraphContext(){return this.currentView=null,this.render(this.lastClick)}initializeGraph(){let e=this.controller.graphs[this.controller.currentOrgan];this.augmentedGraph=new x(e,e.vertices),new q(this.augmentedGraph),new K(this.augmentedGraph),new ue(this.augmentedGraph),new pe(this.augmentedGraph),new fe(this.augmentedGraph);let a=new k(this.augmentedGraph),h=new L(this.augmentedGraph,a.leaves,this.augmentedGraph.verticesCT).slots,c=this.controller.properties.totalWidth,z=new ge(this.augmentedGraph,h,c,c-c/3,this.controller.properties.offsetIncrementTwoLines,this.controller.properties.offsetIncrementTwoLines);new se(h,this.augmentedGraph,z.parameterReplication)}calculateLayoutGraph(e){let t=this.augmentedGraph.verticesAS.slice(0).concat(this.augmentedGraph.verticesCT.slice(0));if(null!=e){let s=new H(this.augmentedGraph,e,this.augmentedGraph.outDegree).createLevels();t=t.concat(s[s.length-1]);let r=s[s.length-2],n=new x(this.augmentedGraph,t);return n.verticesCT.forEach(a=>{a in n.outDegree&&!r.includes(a)&&(n.outDegree[a].forEach(o=>{this.removeByValue(a,n.inDegree[o])}),delete n.outDegree[a])}),this.lastClick=e,n}return new x(this.augmentedGraph,t)}renderRestoreViewContext(){this.render(null!=this.lastClick?this.lastClick:null)}render(e){if(this.controller.graphs[this.controller.currentOrgan].ready){this.firstTime&&this.initializeGraph();let i=this.calculateLayoutGraph(e);return this.renderPartial(i,e).then(()=>this.firstTime=!1).then()}return null}renderPartial(e,t){let s=new Qe(e,t,new V(this.controller.gui.selectedRotation),this.controller.properties),r=new W(e,s,this.controller.properties);this.setGraph2DParameter(r);let a,n=r.exportSpecification(!1);return null!=this.currentView?this.animation(e,s,r):(a=new b.G7x(b.Qc3(n)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("click",(o,h)=>this.displayBM(o,h)).addEventListener("mouseover",(o,h)=>this.toolTip.compute(o,h,e)),this.currentView=a,this.setBackground(this.currentView),this.currentView.runAsync().then(()=>this.previousDrawing=s.drawing).then())}animationTick(e,t,i,s){if(e==t.animation.length-1){this.setGraph2DParameter(i);let r=i.exportSpecification(!1),n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("click",(a,o)=>this.displayBM(a,o)).addEventListener("mouseover",(a,o)=>this.toolTip.compute(a,o,s));return this.updateView(n,this.currentView),this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync()}{i.graphStyle.labelEnabled=!1;let r=i.exportSpecification(!0),n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing"));return this.updateView(n,this.currentView),this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync()}}animation(e,t,i){let s=this.calculateVertices2Move(e,t.drawing,this.previousDrawing),r=new ie(t.drawing,this.calculateSourcePoints(s,this.previousDrawing),s,this.calculateTargetPoints(s,t.drawing),this.frames),n=[];for(let a=0;a<this.frames;a++)setTimeout(()=>{i.vertexPosition=r.animation[a],n.push(this.animationTick(a,r,i,e))},this.frameTime);return Promise.all(n).then()}removeByValue(e,t){let i=t.indexOf(e);-1!=i&&t.splice(i,1)}displayBM(e,t){if(null!=e&&null!=t&&null!=t.datum){let i=t.datum.id;this.augmentedGraph.verticesBM.includes(i)||this.render(i)}}reset(){this.firstTime=!0,this.lastClick=null,this.currentView=null}calculateSourcePoints(e,t){let i=[];return e.forEach(s=>i.push(t[s])),i}calculateTargetPoints(e,t){let i=[];return e.forEach(s=>i.push(t[s])),i}calculateVertices2Move(e,t,i){let s=[];return e.verticesCT.forEach(r=>{r in i&&r in t&&(i[r].x!=t[r].x||i[r].y!=t[r].y)&&s.push(r)}),s}}class de extends _{constructor(e,t,i){super(e,t,i),this.class=M.Subgraph,new q(e),new K(e),this.calculateParameter(),new ue(e),new pe(e);let o=new k(e),c=new L(e,o.leaves,e.verticesCT).slots,m=(new fe(e),new ge(e,c,this.xPositionBM,this.xPositionCT,this.offsetIncrementCT,this.offsetIncrementBM)),O=(new se(c,e,m.parameterReplication),new L(e,c,this.graph.verticesBM).slots);this.drawBiomarkers(O),this.drawCellTypes(c),new he(e,this.drawing,this.depth,this.depthMultiplier,this.offsetIncrementAS),this.calculateWidthHeight(),this.applyLinearMap(t,o)}drawBiomarkers(e){let t=this.properties.heightTopPadding;e.forEach(i=>{let s=new y.S(this.xPositionBM,t);t+=this.offsetIncrementBM,this.drawing[i]=s})}drawCellTypes(e){let t=this.properties.heightTopPadding;this.feasibleClippingCT()?new te(this,e,t):e.forEach(i=>{let s=new y.S(this.xPositionCT,t);t+=this.offsetIncrementCT,this.drawing[i]=s})}}class me extends F{constructor(e){super(e,"Subgraph"),this.currentString="",this.lastID=null}renderRestoreViewContext(){this.firstTime=!1,this.render(null)}renderRestoreGraphContext(){return this.firstTime=!0,this.render(null)}render(e){let t=this.controller.graphs[this.controller.currentOrgan];if(t.ready){let i=new x(t,t.vertices);return this.renderSubgraph(i)}return Promise.reject()}renderSubgraph(e){let i=new de(e,new V(this.controller.gui.selectedRotation),this.controller.properties),s=new W(e,i,this.controller.properties);this.setGraph2DParameter(s);let r=s.exportSpecification(!1),n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("mouseover",(a,o)=>this.toolTip.compute(a,o,e));return this.firstTime||this.updateView(n,this.currentView),this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync().then(()=>{this.firstTime=!1}).then()}processZoom(e,t){let i=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,r=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY,a=this.currentView.scale("xscale"),o=this.currentView.scale("yscale");e.vertices.forEach(m=>{let g=t[m];a(g.x)<i&&(i=a(g.x)),a(g.x)>s&&(s=a(g.x)),o(g.y)<r&&(r=o(g.y)),o(g.y)>n&&(n=o(g.y))});let h=Math.max(Math.abs(s-i),withDrawingDIV),c=Math.max(Math.abs(n-r),heightDrawingDIV),p=this.currentView.signal("anchor");if(console.log("ANCHOR:",p,"XDOM: ",this.currentView.signal("xdom"),"YDOM",this.currentView.signal("ydom")),console.log(h,c,this.currentView.signal("xdom")),this.currentView.container().querySelector("svg").style.width=h+"px",this.currentView.container().querySelector("svg").style.height=c+"px",null!=this.lastWidth){let g=p[1]/this.lastHeight;this.currentView.container().querySelector("svg").scrollTop=-g}this.lastWidth=h,this.lastHeight=c}reset(){this.firstTime=!0,this.currentView=null}}class tt{constructor(e,t){this.bends=[],this.bendCount=-1,this.depth=Number.NEGATIVE_INFINITY,this.exploreThreshhold=t+1;let i=new x(e,e.verticesAS);this.calculatePossibleRoots(e).forEach(r=>{this.treeAugmentation(r,e,i)}),this.processBends(e,i)}treeAugmentation(e,t,i){let r=new H(i,e,i.outDegree).createLevels();this.depth<r.length&&(this.depth=r.length);for(let n=0;n<r.length-1;n++)r[n].forEach(o=>{if(!(o in i.outDegree)){let h=o;if(o in t.inDegree){let c=t.inDegree[o][0],p=[];c in i.outDegree&&(i.outDegree[c].forEach(g=>{g!=o&&p.push(g)}),i.outDegree[c]=p);let m=[];for(let g=n+1;g<Math.min(r.length,n+this.exploreThreshhold);g++)i.outDegree[this.bendCount]=[h],m.push(this.bendCount),h=this.bendCount,this.bendCount=this.bendCount-1;this.bends.push(new ce(c,m,o,o)),c in i.outDegree&&i.outDegree[c].push(h)}}})}processBends(e,t){this.bends.forEach(i=>{let s=i.middleID;s.forEach(n=>{e.vertices.push(n),e.verticesAS.push(n),e.numVertices+=1,e.numVerticesAS+=1,e.vertexType[n]=f.AS,e.vertexColor[n]="red",e.vertexLabel[n]=" ",e.vertexVisible[n]=0,e.vertexSize[n]=300});let r=i.targetID;s.forEach(n=>{n in e.outDegree?e.outDegree[n].push(r):e.outDegree[n]=[r],r in e.inDegree?e.inDegree[r].push(n):e.inDegree[r]=[n],r=n}),e.inDegree[s[s.length-1]]=[i.sourceID],e.outDegree[i.sourceID].push(s[s.length-1]),this.removeByValue(i.targetID,e.outDegree[i.sourceID]),this.removeByValue(i.sourceID,e.inDegree[i.targetID])})}removeByValue(e,t){let i=t.indexOf(e);t.splice(i,1)}calculatePossibleRoots(e){let t=[];return e.verticesAS.forEach(i=>{i in e.inDegree||t.push(i)}),t}}class it{constructor(e){this.dummyID=-9e6,this.leafMap=new Map;let t=new x(e,e.verticesAS);t.vertices.forEach(s=>this.leafMap[s]=!1);let i=this.calculateRoot(t);this.leafWorker(i,t),this.postOrder(i,e)}calculateRoot(e){let t=null;return e.vertices.forEach(i=>{i in e.inDegree||(t=i)}),t}leafWorker(e,t){e in t.outDegree?t.outDegree[e].forEach(i=>{this.leafWorker(i,t)}):this.leafMap[e]=!0}postOrder(e,t){if(e in t.outDegree){let i=[];t.outDegree[e].forEach(s=>{switch(t.vertexType[s]){case f.AS:this.postOrder(s,t);break;case f.CT:this.leafMap[e]||i.push(s)}}),i.length>0&&this.shrinkGraph(t,e,i)}}shrinkGraph(e,t,i){i.forEach(s=>{this.removeByValue(s,e.outDegree[t]),this.removeByValue(t,e.inDegree[s])})}removeByValue(e,t){let i=t.indexOf(e);-1!=i&&t.splice(i,1)}}class st extends F{constructor(e){super(e,"Explore"),this.bfsThreshold=4,this.firstTime=!0,this.frames=25,this.frameTime=700}calculateLayoutGraph(e){(null==e||0==e)&&(this.root=1);let r,t=new H(this.originalGraph,this.root,this.originalGraph.outDegree),i=t.createLevels(),s=[];r=1==this.root?this.bfsThreshold-1:this.bfsThreshold;for(let c=0;c<Math.min(r,i.length);c++)i[c].forEach(p=>{s.push(p)});null!=this.previousGraph&&this.root in this.previousGraph.inDegree?s.push(this.previousGraph.inDegree[this.root][0]):this.root in this.originalGraph.inDegree&&this.originalGraph.inDegree[this.root].forEach(c=>{s.push(c)});let n=new x(this.originalGraph,s);new it(n),new tt(n,r),t=new H(n,this.root,n.outDegree),i=t.createLevels(),s=[];for(let c=0;c<Math.min(r,i.length);c++)i[c].forEach(p=>{s.push(p)});this.root in n.inDegree&&n.inDegree[this.root].forEach(c=>{s.push(c)});let h=new x(n,s);return h.vertices.forEach(c=>{h.vertexSize[c]=this.controller.properties.vertexSize}),h.inDegree[this.root].forEach(c=>{h.vertexColor[c]="black",h.vertexSize[c]=this.controller.properties.rootExplorationVertexSize}),this.previousGraph=h,h}renderRestoreGraphContext(){return this.currentView=null,null!=this.lastClick?this.render(this.lastClick).then():this.render(null).then()}renderRestoreViewContext(){this.render(null!=this.root?this.root:null)}render(e){return this.firstTime&&(this.originalGraph=this.controller.graphs[this.controller.currentOrgan]),this.firstTime=!1,this.controller.graphs[this.controller.currentOrgan].readyPromise.then(t=>{let i=this.calculateLayoutGraph(e);return null!=i?this.renderExplore(i):null})}renderExplore(e){let i=new de(e,new V(this.controller.gui.selectedRotation),this.controller.properties);i.class=M.Exploration;let s=new W(e,i,this.controller.properties);this.setGraph2DParameter(s);let r=s.exportSpecification(!1);if(null==this.currentView){let n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("click",(a,o)=>this.explore(a,o)).addEventListener("mouseover",(a,o)=>this.toolTip.compute(a,o,e));return this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync().then(()=>{this.previousDrawing=i.drawing}).then()}return this.animation(i,e,s).then(()=>this.previousDrawing=i.drawing).then()}animationTick(e,t,i,s){if(e==t.animation.length-1){this.setGraph2DParameter(i);let r=i.exportSpecification(!1),n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("click",(a,o)=>this.explore(a,o)).addEventListener("mouseover",(a,o)=>this.toolTip.compute(a,o,s));return this.updateView(n,this.currentView),this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync()}{i.graphStyle.labelEnabled=!1;let r=i.exportSpecification(!0),n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing"));return this.updateView(n,this.currentView),this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync()}}animation(e,t,i){let s=this.calculateVertices2Move(e.drawing,t),r=new ie(e.drawing,this.calculateSourcePoints(s),s,this.calculateTargetPoints(s,e.drawing),this.frames),n=[];for(let a=0;a<this.frames;a++)setTimeout(()=>{i.vertexPosition=r.animation[a],n.push(this.animationTick(a,r,i,t))},this.frameTime);return Promise.all(n).then()}explore(e,t){if(null!=e&&null!=t){let i=t.datum.id;this.originalGraph.vertexType[i]!=f.BM&&this.originalGraph.vertexType[i]!=f.CT&&(this.root=i,this.render(i)),this.lastClick=i}}reset(){this.firstTime=!0,this.root=1,this.previousGraph=null,this.currentView=null,this.lastClick=null}calculateSourcePoints(e){let t=[];return e.forEach(i=>t.push(this.previousDrawing[i])),t}calculateTargetPoints(e,t){let i=[];return e.forEach(s=>i.push(t[s])),i}calculateVertices2Move(e,t){let i=[];return t.vertices.forEach(s=>{s in this.previousDrawing&&s in e&&(this.previousDrawing[s].x!=e[s].x||this.previousDrawing[s].y!=e[s].y)&&i.push(s)}),i}}var re=S(243);class rt{constructor(e,t,i){this.containment=e,this.drawing=t,this.offset=50,this.rectangles=[],this.smallestWidth=window.screen.width/14,this.recursionSteps=0,this.recursionSteps=0,this.aid=-8e5;let s=this.calculateFakeOutDeg();this.calculateHeight(this.containment.root,1,s),this.recursionSteps-=1,this.offsetCT=i,this.parseRectangles(s)}calculateFakeOutDeg(){this.aid=-8e5;let e=new Map;return this.worker2(this.containment.root,e),e[this.containment.root]=this.containment.outDegree[this.containment.root],e}worker2(e,t){e in this.containment.outDegree&&(1==this.containment.containerState[e]?(this.containment.outDegree[e].forEach(i=>{this.worker2(i,t)}),t[e]=this.containment.outDegree[e]):(this.aid=this.aid-1,t[e]=[this.aid]))}parseRectangles(e){let t=this.containment.root;t in e&&e[t].forEach(i=>{this.worker(i,e,this.recursionSteps)})}worker(e,t,i){if(e in t){let s=this.workerSmallestY(e,t),r=this.workerLargestY(e,t),n=this.smallestWidth*Math.exp(i/this.recursionSteps),a=this.offsetCT/5/this.recursionSteps*i,o=s.x-n/2,h=Math.sqrt(window.screen.height*window.screen.height+window.screen.width*window.screen.width)/2,c=s.y-1.5*Math.sqrt(h)-a;this.rectangles.push(new re.A(o,c,n,r.y-s.y+(s.y-c)+this.offsetCT/2.5/this.recursionSteps*i)),t[e].forEach(E=>{this.worker(E,t,i-1)})}}workerSmallestY(e,t){if(e in t){let i=new y.S(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY);return t[e].forEach(s=>{let r=this.workerSmallestY(s,t);r.y<i.y&&(i=r)}),i}return this.drawing[e]}workerLargestY(e,t){if(e in t){let i=new y.S(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);return t[e].forEach(s=>{let r=this.workerLargestY(s,t);r.y>i.y&&(i=r)}),i}return this.drawing[e]}calculateHeight(e,t,i){e in i?i[e].forEach(s=>{this.calculateHeight(s,t+1,i)}):t>this.recursionSteps&&(this.recursionSteps=t)}}class nt{constructor(e,t,i,s){this.containment=e,this.drawing=t,this.offset=50,this.rectangles=[],this.properties=s,this.smallestWidth=this.properties.heightDrawingDIV/14,this.recursionSteps=0,this.recursionSteps=0;let r=this.calculateFakeOutDeg();this.calculateHeight(this.containment.root,1,r),this.recursionSteps-=1,this.offsetCT=i,this.parseRectangles(r)}calculateFakeOutDeg(){this.aid=-8e5;let e=new Map;return this.worker2(this.containment.root,e),e[this.containment.root]=this.containment.outDegree[this.containment.root],e}worker2(e,t){e in this.containment.outDegree&&(1==this.containment.containerState[e]?(this.containment.outDegree[e].forEach(i=>{this.worker2(i,t)}),t[e]=this.containment.outDegree[e]):(this.aid=this.aid-1,t[e]=[this.aid]))}parseRectangles(e){let t=this.containment.root;t in e&&e[t].forEach(i=>{this.worker(i,this.recursionSteps,e)})}worker(e,t,i){if(e in i){let s=this.workerSmallestX(e,i),r=this.workerLargestX(e,i),n=this.offsetCT/2.5/this.recursionSteps*t,a=this.smallestWidth*Math.exp(t/this.recursionSteps),h=s.x+this.properties.twoLineLabelOffset-n;n=this.offsetCT/2.5/this.recursionSteps*t,this.rectangles.push(new re.A(h,s.y-a/2,r.x-s.x+(s.x-h)+n,a)),i[e].forEach(g=>{this.worker(g,t-1,i)})}}workerSmallestX(e,t){if(e in t){let i=new y.S(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY);return t[e].forEach(s=>{let r=this.workerSmallestX(s,t);r.x<i.x&&(i=r)}),i}return this.drawing[e]}workerSmallestY(e,t){if(e in t){let i=new y.S(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY);return t[e].forEach(s=>{let r=this.workerSmallestY(s,t);r.y<i.y&&(i=r)}),i}return this.drawing[e]}workerLargestX(e,t){if(e in t){let i=new y.S(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);return t[e].forEach(s=>{let r=this.workerLargestX(s,t);r.x>i.x&&(i=r)}),i}return this.drawing[e]}workerLargestY(e,t){if(e in t){let i=new y.S(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY);return t[e].forEach(s=>{let r=this.workerLargestY(s,t);r.y>i.y&&(i=r)}),i}return this.drawing[e]}calculateHeight(e,t,i){e in i?i[e].forEach(s=>{this.calculateHeight(s,t+1,i)}):t>this.recursionSteps&&(this.recursionSteps=t)}}class at{constructor(e,t,i,s,r,n){this.offsetsX=[],this.offsetIncrementAS=r,this.depthMultiplier=n,this.nextConnnectedComponentOffset=s,this.maximumX=0,this.calculatePossibleRoots(e).forEach(o=>{this.nextYonLayer=[],this.drawLayout(o,0,e,t,i),this.nextConnnectedComponentOffset=this.nextYonLayer[this.nextYonLayer.length-1];let h=(this.nextYonLayer.length-1)*this.depthMultiplier;h>this.maximumX&&(this.maximumX=h)})}calculatePossibleRoots(e){let t=[];return e.verticesAS.forEach(i=>{i in e.inDegree||t.push(i)}),t}drawLayout(e,t,i,s,r){void 0===this.nextYonLayer[t]&&this.nextYonLayer.push(this.nextConnnectedComponentOffset);let a,n=t*this.depthMultiplier+50;if(e in s.outDegree&&s.outDegree[e].forEach(h=>{this.drawLayout(h,t+1,i,s,r)}),e in s.outDegree){let o=s.outDegree[e];a=1==o.length?r[o[0]].y:(r[o[0]].y+r[o[o.length-1]].y)/2}else a=this.nextYonLayer[t];r[e]=new y.S(n,a),this.nextYonLayer[t]=this.nextYonLayer[t]+this.offsetIncrementAS}}class ot extends _{constructor(e,t,i,s){super(e,i,s),this.class=M.Containment;let r=new k(e);this.calculateParameter(),this.containment=t;let n=t.containment,a=e.verticesBM;a=new L(e,n,a).slots,this.initializeHighlights(e,this.highlightedEdge),this.drawBiomarkers(a),this.drawCellTypes(n),this.graph.verticesCT.length!=this.graph.vertices.length&&(this.clipBM(a),this.drawCellTypes(n));const h=this.calculateCTSmallestY(n);this.calculateDynamicOffsetIncrementAS(r,n),new at(e,new x(e,e.verticesAS),this.drawing,h,this.offsetIncrementAS,this.depthMultiplier),1==r.leaves.length&&this.centerAS(),this.applyLinearMap(i,r);let p=this.calculateFakeOutDeg();0==i.rotateAngle||90==i.rotateAngle?(this.containmentRects=new rt(t,this.drawing,this.offsetIncrementCT),this.rects=this.containmentRects.rectangles,this.adjustmentWorker(this.containment.root,null,p)):(this.containmentRects=new nt(t,this.drawing,this.offsetIncrementCT,s),this.rects=this.containmentRects.rectangles,this.adjustmentWorker(this.containment.root,null,p)),this.calculateWidthHeight()}test(e){if(e in this.graph.inDegree){let t="";this.graph.inDegree[e].forEach(i=>{t+=this.graph.vertexLabel[i]})}}centerAS(){let e=Number.POSITIVE_INFINITY,t=Number.NEGATIVE_INFINITY;this.graph.verticesCT.forEach(s=>{let r=this.drawing[s].y;r<e&&(e=r),r>t&&(t=r)});let i=(e+t)/2;this.graph.verticesAS.forEach(s=>{this.drawing[s].y=i})}formatLabelTwoLines(e,t){let i=e.vertexLabel[t];if("string"==typeof i){let s=i.split(" "),r="",n="",a=0;return s.forEach(o=>{a>i.length/3?n=n+" "+o:r=r+" "+o,a+=o.length}),n.length>0?[r,n]:[r]}return i}calculateCTSmallestY(e){let t=Number.POSITIVE_INFINITY;return e.forEach(i=>{this.drawing[i].y<t&&i in this.graph.inDegree&&(t=this.drawing[i].y)}),t}calculateCTLargestY(e){let t=Number.NEGATIVE_INFINITY;return e.forEach(i=>{this.drawing[i].y>t&&i in this.graph.inDegree&&(t=this.drawing[i].y)}),t}adjustmentWorker(e,t,i){if(e in i)i[e].forEach(s=>{this.adjustmentWorker(s,e,i)});else if(e in this.containment.artificialIDToInnerVertex){let n=this.containmentRects.rectangles[this.containment.artificialIdRectIDMap[this.containment.artificialIDToInnerVertex[e][0]]];this.drawing[e]=new y.S(n.positionX+n.width/2,n.positionY+n.height/2)}}calculateDynamicOffsetIncrementAS(e,t){let i=this.calculateCTLargestY(t)-this.calculateCTSmallestY(t);if(e.leaves.length>1){let s=i/(e.leaves.length-1);s>this.offsetIncrementAS&&(this.offsetIncrementAS=s)}}clipBM(e){if(e.length>1){let t=[e[0]],i=this.graph.inDegree[e[0]][0],s=0;for(let r=1;r<e.length;r++){let n=e[r];n in this.graph.inDegree?this.graph.inDegree[n].includes(i)?t.push(n):(s=this.redrawBM(t,i,s),t=[n],i=this.graph.inDegree[e[r]][0]):this.drawing[n]=new y.S(this.drawing[n].x,this.drawing[e[r-1]]+this.offsetIncrementBM)}this.redrawBM(t,i,s)}}redrawBM(e,t,i){const s=this.drawing[t],r=Math.floor(e.length/2);for(let a=0;a<e.length;a++)this.drawing[e[a]]=new y.S(this.drawing[e[a]].x,a<r?s.y-(a+1)*this.offsetIncrementBM:s.y+(a-r)*this.offsetIncrementBM);let n=s.y-r*this.offsetIncrementBM;if(Math.abs(i-n)<this.offsetIncrementBM||n<i){this.drawing[e[0]]=new y.S(this.drawing[e[0]].x,i+this.offsetIncrementBM);for(let a=1;a<e.length;a++)this.drawing[e[a]]=new y.S(this.drawing[e[a]].x,this.drawing[e[a-1]].y+this.offsetIncrementBM)}return this.drawing[e[e.length-1]].y}spacingCTRectangles(e){let t=new Map;e.forEach(s=>t[s]=!1);let i=this.calculateFakeOutDeg();null!=i&&(this.criticalWorker(this.containment.root,this.containment,t,i),this.processCriticalCT(e,t))}calculateFakeOutDeg(){this.aid=-8e5;let e=new Map;return this.worker2(this.containment.root,e),e[this.containment.root]=this.containment.outDegree[this.containment.root],e}worker2(e,t){e in this.containment.outDegree&&(1==this.containment.containerState[e]?(this.containment.outDegree[e].forEach(i=>{this.worker2(i,t)}),t[e]=this.containment.outDegree[e]):(this.aid=this.aid-1,t[e]=[this.aid]))}processCriticalCT(e,t){for(let i=0;i<e.length-1;i++){let s=e[i],r=e[i+1],n=this.drawing[r].y-this.drawing[s].y;t[s]&&n<1.2*this.offsetIncrementCT?this.drawing[r].y=this.drawing[s].y+1.2*this.offsetIncrementCT:n<this.offsetIncrementCT&&(this.drawing[r].y=this.drawing[s].y+this.offsetIncrementCT)}}criticalWorker(e,t,i,s){if(e in s){let r=s[e];i[r[r.length-1]]=!0,r.forEach(n=>{this.criticalWorker(n,t,i,s)})}}drawBiomarkers(e){let t=this.offsetIncrementBM;e.forEach(i=>{let s=new y.S(this.xPositionBM,t);t+=this.offsetIncrementBM,this.drawing[i]=s})}drawCellTypes(e){let t=this.offsetIncrementCT;this.graph.vertices.length!=this.graph.verticesCT.length?new te(this,e,t):e.forEach(i=>{let s=new y.S(this.xPositionCT,t);t+=this.offsetIncrementCT,this.drawing[i]=s}),this.spacingCTRectangles(e)}}class ye{constructor(e,t){this.graph=e,this.containment=t,this.CTRectMap=new Map,t.containment.forEach(i=>{this.CTRectMap[i]=this.search(t,i)}),this.artificialBMID=-85e4,this.replicateBM()}search(e,t){let i=null,s=e.outDegree;for(const[r,n]of Object.entries(s))n.includes(t)&&(i=r);return i}createIndeg(){let e=this.containment.containment,t=new Map;return e.forEach(i=>{i in this.graph.outDegree&&this.graph.outDegree[i].forEach(s=>{t[s]=s in t?t[s].concat([i]):[i]})}),t}replicateBM(){this.createIndeg(),this.graph.verticesBM.forEach(t=>{if(t in this.graph.inDegree){let i=new Map;this.graph.inDegree[t].forEach(r=>{let n=this.CTRectMap[r];n in i?i[n].push(r):i[n]=[r]});let s=!0;for(const[r,n]of Object.entries(i))s?s=!1:this.augment(t,n)}})}augment(e,t){this.graph.vertices.push(this.artificialBMID),this.graph.verticesBM.push(this.artificialBMID),this.graph.numVertices+=1,this.graph.numVerticesBM+=1,this.graph.vertexType[this.artificialBMID]=f.BM,this.graph.vertexLabel[this.artificialBMID]=this.graph.vertexLabel[e],this.graph.IDtoOntologyType[this.artificialBMID]=this.graph.IDtoOntologyType[e],this.graph.IDtoOntologyID[this.artificialBMID]=this.graph.IDtoOntologyID[e],this.graph.vertexSize[this.artificialBMID]=this.graph.vertexSize[e],this.graph.vertexVisible[this.artificialBMID]=1,this.graph.vertexColor[this.artificialBMID]=this.graph.vertexColor[e],t.forEach(i=>{this.graph.outDegree[i].push(this.artificialBMID),this.artificialBMID in this.graph.inDegree?this.graph.inDegree[this.artificialBMID].push(i):this.graph.inDegree[this.artificialBMID]=[i]}),t.forEach(i=>{this.removeByValue(i,this.graph.inDegree[e]),this.removeByValue(e,this.graph.outDegree[i])}),this.artificialBMID-=1}removeByValue(e,t){let i=t.indexOf(e);-1!=i&&t.splice(i,1)}}class lt{constructor(e,t,i){this.properties=i,this.containment=e,this.modelGraph=this.calculateModelGraph(t),this.containmentGraph=this.calculateContainmentGraph(this.modelGraph)}evaluate(e){1==this.containment.containerState[this.containment.rectIDArtificialIDMap[e]]?this.collapse(e):this.expand(e)}expand(e){this.containment.expand(this.containment.rectIDArtificialIDMap[e]),this.containment.update(),this.containmentGraph=this.calculateContainmentGraph(this.modelGraph)}customDelete(e,t){let i=[];for(let s=0;s<e.length;s++){let r=e[s];-1==t.indexOf(r)&&i.push(r)}return i}collapse(e){this.containment.collapse(this.containment.rectIDArtificialIDMap[e]),this.containment.update(),this.containmentGraph=this.calculateContainmentGraph(this.modelGraph)}reset(){this.containment.reset()}calculateContainmentGraph(e){let t=[],i=[];this.containment.containment.forEach(g=>{g in this.containment.artificialIDToInnerVertex?i.push(g):t.push(g)});let s=new Set;t.forEach(g=>{g in e.outDegree&&e.outDegree[g].forEach(E=>{s.add(E)})});let r=Array.from(s),n=new k(e),a=new Set;n.leaves.forEach(g=>{g in e.outDegree&&e.outDegree[g].forEach(E=>{t.includes(E)&&a.add(g)})});let o=Array.from(a),h=new Map;e.verticesAS.forEach(g=>h[g]=!1),o.forEach(g=>{this.tcontWorker(e,g,h)});let c=[];e.verticesAS.forEach(g=>{1==h[g]&&c.push(g)});let p=t.concat(r).concat(c),m=new x(e,p);return i.forEach(g=>{this.addBlackVertex(g,m)}),m}tcontWorker(e,t,i){if(i[t]=!0,t in e.inDegree){let r=e.inDegree[t][0];0==i[r]&&this.tcontWorker(e,r,i)}}calculateModelGraph(e){let t=new x(e,e.vertices),s=(new q(t),new K(t));return this.depth=s.depth,new ye(t,this.containment),t}affectedCT(e){if(e in this.containment.outDegree){let t=[];return this.containment.outDegree[e].forEach(i=>{t=t.concat(this.affectedCT(i))}),t}return[e]}addBlackVertex(e,t){let s=this.affectedCT(this.containment.artificialIDToInnerVertex[e]),r=0;s.forEach(h=>{h in this.modelGraph.outDegree&&(r+=this.modelGraph.outDegree[h].length)});let n=this.properties.maxContainmentCollapsedVertexSize,a=this.properties.vertexSize;a+=r>12?n:r*(n/12),t.addVertex(f.CT,e,"black",1,a,""+r)}}class ht{constructor(e,t,i){this.properties=i,this.containment=e,this.modelGraph=this.calculateModelGraph(t),this.containmentGraph=this.calculateContainmentGraph(this.modelGraph)}evaluate(e){1==this.containment.containerState[this.containment.rectIDArtificialIDMap[e]]?this.collapse(e):this.expand(e)}expand(e){this.containment.expand(this.containment.rectIDArtificialIDMap[e]),this.containment.update(),this.containmentGraph=this.calculateContainmentGraph(this.modelGraph)}customDelete(e,t){let i=[];for(let s=0;s<e.length;s++){let r=e[s];-1==t.indexOf(r)&&i.push(r)}return i}collapse(e){this.containment.collapse(this.containment.rectIDArtificialIDMap[e]),this.containment.update(),this.containmentGraph=this.calculateContainmentGraph(this.modelGraph)}reset(){this.containment.reset()}calculateContainmentGraph(e){let t=[],i=[];this.containment.containment.forEach(p=>{p in this.containment.artificialIDToInnerVertex?i.push(p):t.push(p)});let s=new k(e),r=new Set;s.leaves.forEach(p=>{p in e.outDegree&&e.outDegree[p].forEach(m=>{t.includes(m)&&r.add(p)})});let n=Array.from(r),a=new Map;e.verticesAS.forEach(p=>a[p]=!1),n.forEach(p=>{this.tcontWorker(e,p,a)});let o=[];e.verticesAS.forEach(p=>{1==a[p]&&o.push(p)});let h=t.concat(o),c=new x(e,h);return i.forEach(p=>{this.addBlackVertex(p,c,e)}),c}tcontWorker(e,t,i){if(i[t]=!0,t in e.inDegree){let r=e.inDegree[t][0];0==i[r]&&this.tcontWorker(e,r,i)}}calculateModelGraph(e){let t=new x(e,e.vertices),s=(new q(t),new K(t));return this.depth=s.depth,new ye(t,this.containment),t}affectedCT(e){if(e in this.containment.outDegree){let t=[];return this.containment.outDegree[e].forEach(i=>{t=t.concat(this.affectedCT(i))}),t}return[e]}countExpansion(e,t){if(this.expansionlabel[e])return 0;if(this.expansionlabel[e]=!0,e in t.inDegree){let i=1;return e<0&&(i-=1),i+this.countExpansion(t.inDegree[e][0],t)}return 1}addBlackVertex(e,t,i){let r=this.affectedCT(this.containment.artificialIDToInnerVertex[e]);console.log("AFFECTED",r,t.verticesCT,i.verticesCT);let n=0;this.expansionlabel=new Map,i.verticesAS.forEach(c=>this.expansionlabel[c]=!1),r.forEach(c=>{c in i.inDegree&&i.inDegree[c].forEach(p=>{n+=this.countExpansion(p,i)})}),console.log("REACHABLE CT",r,"ACC LENGTH: ",n,"OUTDEG INITIAL GRAPH",t.inDegree);let a=this.properties.maxContainmentCollapsedVertexSize,o=this.properties.vertexSize;o+=n>12?a:n*(a/12),t.addVertex(f.CT,e,"black",1,o,""+n)}}class ct{constructor(e,t,i){this.graph=e,this.vFixed=t,this.vFree=i,this.calculateLinearOrders(),this.calculateEdges(),this.calculateCrossings()}calculateLinearOrders(){this.orderFixed=new Map;for(let e=0;e<this.vFixed.length;e++)this.orderFixed[this.vFixed[e]]=e+1;this.orderFree=new Map;for(let e=0;e<this.vFree.length;e++)this.orderFree[this.vFree[e]]=e+1}calculateEdges(){this.bipartiteEdges=[],this.vFixed.forEach(e=>{e in this.graph.outDegree&&this.graph.outDegree[e].forEach(t=>{this.vFree.includes(t)&&this.bipartiteEdges.push({source:e,target:t})})})}calculateCrossings(){this.crossings=0,this.bipartiteEdges.forEach(e=>{this.bipartiteEdges.forEach(t=>{e.source==t.source&&e.target==t.target||this.isCrossing(e,t)&&(this.crossings+=1)})}),this.crossings=.5*this.crossings}isCrossing(e,t){return(this.orderFixed[e.source]-this.orderFixed[t.source])*(this.orderFree[e.target]-this.orderFree[t.target])<0}}class ve{constructor(e,t){this.permutations=s=>s.length<=2?2===s.length?[s,[s[1],s[0]]]:s:s.reduce((r,n,a)=>r.concat(this.permutations([...s.slice(0,a),...s.slice(a+1)]).map(o=>[n,...o])),[]),this.containment=e,this.graph=t,this.vFixed=new k(this.graph).leaves,this.reorder(this.containment.root),this.containment.update()}reorder(e){if(e in this.containment.outDegree){let t=[];this.containment.outDegree[e].forEach(h=>{t.push(this.reorder(h))});let i=Array.from(t.keys()),s=this.permutations(i),r=[],n=[],a=Number.POSITIVE_INFINITY;for(let h=0;h<s.length;h++){let c=s[h],p=[];c.forEach(g=>p=p.concat(t[g]));let m=new ct(this.graph,this.vFixed,p).crossings;m<a&&(a=m,r=c,n=p)}let o=[];return r.forEach(h=>o.push(this.containment.outDegree[e][h])),this.containment.outDegree[e]=o,n}return[e]}}class we extends F{constructor(e,t){super(e,"Containment"),this.frames=25,this.frameTime=700,this.controller=e,this.hideBM=t}renderRestoreGraphContext(){return this.currentView=null,this.render(null)}renderRestoreViewContext(){this.firstTime=!1,this.render(null).then()}render(e){let t=this.controller.graphs[this.controller.currentOrgan];return t.ready?this.renderSubgraph(t):Promise.reject()}animationTick(e,t,i,s,r){if(e==t.animation.length-1){i.graphStyle.labelEnabled=this.controller.gui.appearance[0].sel;let n=i.exportSpecification(!1),a=new b.G7x(b.Qc3(n)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("click",(o,h)=>this.calculateContainer(o,h,r)).addEventListener("mouseover",(o,h)=>this.toolTip.compute(o,h,s));return this.setBackground(this.currentView),this.updateView(a,this.currentView),this.currentView=a,this.currentView.runAsync()}{i.graphStyle.labelEnabled=!1;let n=i.exportSpecification(!1),a=new b.G7x(b.Qc3(n)).renderer("svg").initialize(document.querySelector("#drawing"));return this.setBackground(a),this.updateView(a,this.currentView),this.currentView=a,a.runAsync()}}renderSubgraph(e){this.firstTime&&this.firstTimeProcessing(e);let i=new ot(this.containmentGraph,this.manager.containment,new V(this.controller.gui.selectedRotation),this.controller.properties),s=new W(this.containmentGraph,i,this.controller.properties);if(this.setGraph2DParameter(s),null!=this.currentView){let r=this.calculateVertices2Move(i.drawing),n=new ie(i.drawing,this.calculateSourcePoints(r),r,this.calculateTargetPoints(r,i.drawing),this.frames),a=[];for(let o=0;o<this.frames;o++)setTimeout(()=>{s.vertexPosition=n.animation[o],a.push(this.animationTick(o,n,s,e,i))},this.frameTime);return Promise.all(a).then(()=>{this.firstTime=!1,this.previousDrawing=i.drawing}).then()}{let r=s.exportSpecification(!1),n=new b.G7x(b.Qc3(r)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("click",(a,o)=>this.calculateContainer(a,o,i)).addEventListener("mouseover",(a,o)=>this.toolTip.compute(a,o,e));return this.currentView=n,this.setBackground(this.currentView),this.currentView.runAsync().then(()=>{this.firstTime=!1,this.previousDrawing=i.drawing}).then()}}calculateSourcePoints(e){let t=[];return e.forEach(i=>t.push(this.previousDrawing[i])),t}calculateTargetPoints(e,t){let i=[];return e.forEach(s=>i.push(t[s])),i}calculateVertices2Move(e){let t=[];return this.containmentGraph.verticesCT.forEach(i=>{i in this.previousDrawing&&i in e&&(this.previousDrawing[i].x!=e[i].x||this.previousDrawing[i].y!=e[i].y)&&t.push(i)}),this.containmentGraph.verticesBM.forEach(i=>{i in this.previousDrawing&&i in e&&(this.previousDrawing[i].x!=e[i].x||this.previousDrawing[i].y!=e[i].y)&&t.push(i)}),t}calculateContainer(e,t,i){if(null!=t&&null!=e&&"rect"==t.mark.marktype){let s=this.calculateRectIndex(e,i.rects);null!=s&&(this.manager.evaluate(s),this.containmentGraph=this.manager.containmentGraph,this.render(null))}}calculateRectIndex(e,t){console.log("CHROMEBS",e);let i=e.target.__data__.datum,s=new re.A(i.x,i.y,i.w,i.h),r=null;for(let n=0;n<t.length;n++)if(t[n].positionX==s.positionX&&t[n].positionY==s.positionY){r=n;break}return r}firstTimeProcessing(e){let t=this.fetchContainmentIndex(),i=this.controller.graphs[this.controller.currentOrgan].containment;i.root=-1==t?i.initialRoot:i.outDegree[i.initialRoot][t-1],i.update(),this.hideBM?(this.manager=new ht(i,e,this.controller.properties),new ve(this.manager.containment,this.manager.containmentGraph)):(this.manager=new lt(i,e,this.controller.properties),new ve(this.manager.containment,this.manager.containmentGraph)),this.containmentGraph=this.manager.containmentGraph}fetchContainmentIndex(){let e=this.controller.gui.selectedContainer;if("All Container"==e)return-1;{let t=e.split("Container ");return parseInt(t[1])}}reset(){this.firstTime=!0,null!=this.manager&&this.manager.reset(),this.currentView=null}}class ut{constructor(e,t,i,s,r,n){this.offsetsX=[],this.depthMultiplier=n,this.nextConnnectedComponentOffset=s,this.maximumX=0,this.offsetIncrementAS=r,this.calculatePossibleRoots(e).forEach(o=>{this.nextYonLayer=[],this.drawLayout(o,0,e,t,i),this.nextConnnectedComponentOffset=this.nextYonLayer[this.nextYonLayer.length-1];let h=(this.nextYonLayer.length-1)*this.depthMultiplier;h>this.maximumX&&(this.maximumX=h)})}calculatePossibleRoots(e){let t=[];return e.verticesAS.forEach(i=>{i in e.inDegree||t.push(i)}),t}drawLayout(e,t,i,s,r){void 0===this.nextYonLayer[t]&&this.nextYonLayer.push(this.nextConnnectedComponentOffset);let a,n=t*this.depthMultiplier+50;if(e in s.outDegree&&s.outDegree[e].forEach(h=>{this.drawLayout(h,t+1,i,s,r)}),e in s.outDegree){let o=s.outDegree[e];a=1==o.length?Math.max(r[o[0]].y,this.nextYonLayer[t]+2*this.offsetIncrementAS):Math.max((r[o[0]].y+r[o[o.length-1]].y)/2,this.nextYonLayer[t]+2*this.offsetIncrementAS)}else a=this.nextYonLayer[t]+2*this.offsetIncrementAS;r[e]=new y.S(n,a),this.nextYonLayer[t]=this.nextYonLayer[t]+2*this.offsetIncrementAS}}class pt extends _{constructor(e,t,i){super(e,t,i),this.class=M.Subgraph,this.calculateParameter(),this.drawBiomarkers(this.graph.verticesBM),this.drawCellTypes(this.graph.verticesCT),new ut(e,new x(e,e.verticesAS),this.drawing,this.offsetIncrementAS,this.offsetIncrementAS,this.depthMultiplier),this.calculateWidthHeight(),this.applyLinearMap(t,new k(e))}drawBiomarkers(e){let t=this.properties.heightTopPadding;e.forEach(i=>{let s=new y.S(this.xPositionBM,t);t+=this.offsetIncrementBM,this.drawing[i]=s})}drawCellTypes(e){let t=this.properties.heightTopPadding;e.forEach(i=>{let s=new y.S(this.xPositionCT,t);t+=this.offsetIncrementCT,this.drawing[i]=s})}}class ft extends F{constructor(e){super(e,"Original")}renderRestoreGraphContext(){return this.firstTime=!0,this.render(null)}renderRestoreViewContext(){this.firstTime=!1,this.render(null)}render(e){let t=this.controller.graphs[this.controller.currentOrgan];if(t.ready){let i=this.controller.gui.selectedRotation,r=(new x(t,t.vertices),new pt(t,new V(i),this.controller.properties)),n=new W(t,r,this.controller.properties);this.setGraph2DParameter(n);let a=n.exportSpecification(!1),o=new b.G7x(b.Qc3(a)).renderer("svg").initialize(document.querySelector("#drawing")).addEventListener("mouseover",(h,c)=>this.toolTip.compute(h,c,t));return this.firstTime||this.updateView(o,this.currentView),this.currentView=o,this.setBackground(this.currentView),this.currentView.runAsync().then(()=>this.firstTime=!1).then()}return null}reset(){this.firstTime=!0,this.currentView=null}}class gt{constructor(e){this.initializeGraphs(),this.gui=e,this.currentOrgan=u.Kidney,this.properties=new Y,this.currentMode=new me(this)}initializeGraphs(){this.graphs=[new T([u.BoneMarrow]),new T([u.Brain]),new T([u.Heart]),new T([u.Kidney]),new T([u.LargeIntestine]),new T([u.Lung]),new T([u.LymphNodes]),new T([u.Skin]),new T([u.Spleen]),new T([u.Thymus]),new T([u.Vasculature])]}updateMode(e){null!=this.currentMode&&this.currentMode.reset(),"Partial Graph"==e?this.currentMode=new et(this):"Complete Graph"==e?this.currentMode=new me(this):"Exploration"==e?this.currentMode=new st(this):"Containment"==e?this.currentMode=new we(this,!this.gui.modes[0].sel):"Unmodified Graph"==e&&(this.currentMode=new ft(this))}updateOrgan(e){this.currentOrgan=function(l){switch(l){case"Bone Marrow":return u.BoneMarrow;case"Brain":return u.Brain;case"Heart":return u.Heart;case"HeartWithCTTypology":return u.HeartWithCTTypology;case"Kidney":return u.Kidney;case"Large Intestine":return u.LargeIntestine;case"Lung":return u.Lung;case"Lymph Nodes":return u.LymphNodes;case"Skin":return u.Skin;case"Spleen":return u.Spleen;case"Thymus":return u.Thymus;case"Vasculature":return u.Vasculature;case"All":return u.All;default:return null}}(e),this.currentMode.reset()}renderRestore(){this.currentMode.renderRestoreViewContext(),this.f()}render(){return this.currentMode.render(null).then(()=>this.f()).then()}restore90270(){let e=document.getElementById("drawing");e.style.overflowY="hidden",e.style.overflowX="scroll"}restore0180(){let e=document.getElementById("drawing");e.style.overflowY="scroll",e.style.overflowX="hidden"}f(){let e=new V(this.gui.selectedRotation);180==e.rotateAngle||270==e.rotateAngle?this.restore90270():this.restore0180()}}}}]);